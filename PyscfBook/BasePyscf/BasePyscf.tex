% !TeX program = lualatex
% !TeX encoding = utf8
% !TeX spellcheck = uk_UA
% !TeX root =../PyscfBook.tex

%=========================================================
\Opensolutionfile{answer}[\currfilebase/\currfilebase-Answers]
\chapter{Базові об'єкти PySCF}\label{\currfilebase}
%=========================================================

%% --------------------------------------------------------
\section{Молекулярний об'єкт (Mole)}
%% --------------------------------------------------------


%% --------------------------------------------------------
\subsection{Клас Mole --- серце PySCF}
%% --------------------------------------------------------

Клас \inlinecode{gto.Mole} є центральним об'єктом у бібліотеці \textbf{PySCF} (Python-based Simulations of Chemistry Framework).
Цей клас визначає і зберігає всю інформацію про атомну або молекулярну систему, яка необхідна для квантово-хімічних розрахунків.
Саме з нього починається будь-який проєкт у PySCF, адже всі інші модулі (SCF, DFT, MP2, CCSD тощо) працюють із вже побудованим об'єктом \inlinecode{Mole}.

Об’єкт \inlinecode{Mole} містить такі основні дані:
\begin{itemize}
    \item \textbf{Геометрію системи} --- координати атомів у просторі (в ангстремах або борах);
    \item \textbf{Базисний набір} --- набір функцій, на яких розкладаються молекулярні орбіталі;
    \item \textbf{Заряд системи} та \textbf{спін} (мультиплетність);
    \item \textbf{Інформацію про симетрію} (за потреби);
    \item \textbf{Одиниці вимірювання} (ангстреми, бори).
\end{itemize}

Таким чином, \inlinecode{Mole} виконує роль «серця» всієї програми --- воно зберігає стан квантової системи і передає цю інформацію до інших підсистем для проведення обчислень.

%% --------------------------------------------------------
\subsection{Створення об'єкта Mole}
%% --------------------------------------------------------

Існує два основні способи створення молекулярного об'єкта: або за допомогою скороченого конструктора, або покроково.
Обидва підходи рівноцінні за результатом, однак відрізняються стилем запису.

\paragraph{Метод 1: Використання конструктора \inlinecode{ Mole()}}

Цей спосіб є найзручнішим для простих систем, коли всі параметри можна вказати безпосередньо при створенні об'єкта:


\inputcode{MoleCreationMethod1.py}


Тут:
\begin{itemize}
    \item \inlinecode{atom='Li 0 0 0'} --- визначає атом літію в координатах (0, 0, 0);
    \item \inlinecode{basis='6-31g'} --- вказує базисний набір для розрахунків;
    \item \inlinecode{charge=0} --- нейтральний атом;
    \item \inlinecode{spin=1} --- означає, що система має $2S = 1$, тобто один неспарений електрон.
\end{itemize}

Функція \inlinecode{gto.Mole()} автоматично створює об’єкт, налаштовує всі параметри та викликає \inlinecode{.build()}.

\paragraph{Метод 2: Покрокове налаштування}

Цей спосіб зручний для складних систем, де потрібно задати багато параметрів або змінювати їх під час роботи:

\inputcode{MoleCreationMethod2.py}

\textbf{Важливо:} При використанні другого методу обов'язково викликати команду \inlinecode{mol.build()},
інакше PySCF не згенерує внутрішні структури (матриці, орбіталі, таблиці інтегралів тощо), необхідні для подальших розрахунків.

%% --------------------------------------------------------
\subsection{Основні атрибути об'єкта Mole}
%% --------------------------------------------------------

Після побудови об'єкта можна отримати детальну інформацію про систему.
Ось приклад, який демонструє найпоширеніші атрибути:

\inputcode{SystemMainInfo.py}

\noindent
Ці атрибути особливо важливі для перевірки, чи правильно задані всі вхідні параметри перед запуском складних обчислень.

\begin{itemize}
    \item \inlinecode{mol.nelectron} --- кількість електронів у системі;
    \item \inlinecode{mol.charge} --- сумарний заряд системи;
    \item \inlinecode{mol.spin} --- подвоєне значення спіну ($2S$);
    \item \inlinecode{mol.nao\_nr()} --- кількість базисних орбіталей (число функцій, які будуть використані в обчисленнях);
    \item \inlinecode{mol.nelec} --- кортеж \inlinecode{(n\_alpha, n\_beta)} з кількістю альфа- та бета-електронів;
    \item \inlinecode{mol.natm} --- кількість атомів у системі;
    \item \inlinecode{mol.atom\_charges()} --- масив ядерних зарядів;
    \item \inlinecode{mol.basis} --- опис обраного базисного набору.
\end{itemize}

\noindent
Типовий вивід програми для атома кисню:

\begin{minted}{bash}
Кількість електронів: 8
Заряд: 0
Спін (2S): 2
Кількість базисних функцій: 18
Альфа електронів: 5
Бета електронів: 3
Кількість атомів: 1
Заряди ядер: [8.]
Назва базису: 6-31g
\end{minted}

Такий вивід дозволяє переконатися, що система побудована коректно, а параметри відповідають фізичному змісту задачі.
Наприклад, у цьому випадку маємо нейтральний атом кисню ($Z=8$, $N_e=8$), у якого спін $S=1$ (два неспарені електрони).


Після побудови об’єкта \inlinecode{Mole} його можна передавати до будь-яких методів PySCF --- від найпростіших \inlinecode{SCF} до корельованих методів \texttt{CCSD}, \texttt{CASCI} та інших.
Тому розуміння структури і властивостей цього класу є ключем до ефективного використання всієї бібліотеки.


%% --------------------------------------------------------
\subsection{Визначення атома: різні способи}
%% --------------------------------------------------------

Визначення атома або атомів --- це перший крок при побудові квантово-хімічної моделі.
У PySCF координати та типи атомів можна задавати кількома способами.
Усі вони приводять до одного й того ж результату, тому вибір форми запису залежить лише від зручності.

\paragraph{Спосіб 1: Рядок}

Цей варіант є найпростішим і найчастіше використовується для одиночних атомів або малих систем.
Формат: \inlinecode{<атом> x y z}, де координати задаються в ангстремах за замовчуванням (або в борах, якщо \inlinecode{unit='Bohr'}).

\inputcode{AtomDefinitionWay1.py}

Як видно, PySCF дозволяє вказувати елемент як за його хімічним символом, так і за атомним номером.
У другому випадку він автоматично розпізнає елемент періодичної системи.

\paragraph{Спосіб 2: Список або кортеж}

Якщо потрібно задати кілька атомів, або якщо координати отримуються програмно (наприклад, з масиву),
зручно використовувати структуру даних типу \texttt{list} або \texttt{tuple}.
Кожен атом описується як пара: \inlinecode{[ім'я, (x, y, z)]}.

\inputcode{AtomDefinitionWay2.py}

Така форма є більш універсальною --- вона дозволяє легко зчитувати геометрію з файлів,
генерувати координати циклом або будувати складні молекули.
Наприклад, молекула водню \ce{H2} може бути задана як:
\[
\inlinecode{atom = [['H', (0, 0, 0)], ['H', (0, 0, 0.74)]]}
\]
де відстань у 0.74 Å відповідає типовій довжині зв’язку H–H.

%% --------------------------------------------------------
\subsection{Робота з іонами}
%% --------------------------------------------------------

Клас \inlinecode{Mole} дозволяє легко моделювати заряджені системи --- катіони та аніони.
Для цього достатньо змінити параметр \inlinecode{charge}, який визначає сумарний заряд системи:
\[
Q = Z_\text{ядер} - N_\text{електронів}
\]

Крім того, слід відповідно скоригувати \inlinecode{spin}, який задає подвоєне значення спіну $2S$.
Для нейтральних атомів значення спіну зазвичай відповідає їхній електронній конфігурації.

\inputcode{IonsExample.py}

У цьому прикладі можна побачити, як зміна заряду впливає на кількість електронів:
\begin{itemize}
    \item Нейтральний атом \ce{Li} має 3 електрони;
    \item Катіон \ce{Li} --- 2 електрони (втратив один);
    \item Аніон \ce{Li-} --- 4 електрони (отримав додатковий).
\end{itemize}

Такі прості зміни параметрів дозволяють вивчати іонізаційні енергії, електронну спорідненість,
а також порівнювати властивості нейтральних і заряджених систем.

%% --------------------------------------------------------
\subsection{Налаштування вербальності виводу}
%% --------------------------------------------------------

PySCF має вбудований механізм керування докладністю текстового виводу (тобто <<балакучістю>> програми).
Це зручно, коли потрібно або бачити повну діагностику, або, навпаки, приховати проміжні повідомлення при пакетних розрахунках.

Рівень керується параметром \inlinecode{verbose}:
\[
\texttt{0 = тихо}, \quad
\texttt{4 = стандартно}, \quad
\texttt{9 = детально (debug)}
\]


\inputcode{VerbosityExample.py}


\noindent
У практиці рекомендується:
\begin{itemize}
    \item Використовувати \inlinecode{verbose=4} для навчальних цілей, щоб бачити хід побудови базису та інтегралів;
    \item Використовувати \inlinecode{verbose=0} або \inlinecode{1} при серійному запуску розрахунків на кластері, щоб уникнути перевантаження логів;
    \item Для діагностики чи налагодження коду --- \inlinecode{verbose=7-9}, що дає максимально деталізований вивід.
\end{itemize}

Таким чином, параметр \inlinecode{verbose} дозволяє зручно регулювати ступінь деталізації повідомлень під час обчислень,
роблячи роботу з PySCF більш контрольованою і зручною як для навчання, так і для автоматизованих досліджень.


%% --------------------------------------------------------
\section{Базисні набори для атомів}
%% --------------------------------------------------------


%% --------------------------------------------------------
\subsection{Типи базисних наборів}
%% --------------------------------------------------------

У методах квантової хімії атомні орбіталі представлені не аналітичними розв’язками рівняння Шредінгера,
а певними апроксимаціями --- \textbf{базисними функціями}.
Сукупність цих функцій для всіх атомів системи називається \textbf{базисним набором (basis set)}.

Базис задає, скільки функцій використовується для опису кожної орбіталі (1s, 2p, 3d, ...),
та яку форму вони мають (наприклад, гаусівські чи слейтерівські орбіталі).
Від вибору базисного набору залежить баланс між швидкістю розрахунку та точністю енергії.

У PySCF базис задається через параметр \inlinecode{basis='...'},
і можна використовувати як стандартні бібліотечні набори, так і власні, створені вручну.

%% --------------------------------------------------------
\subsubsection{Мінімальні базиси}
%% --------------------------------------------------------

Мінімальний базис --- це найпростіший опис, коли на кожну атомну орбіталь використовується рівно одна базисна функція.
Наприклад, для атома вуглецю (1s, 2s, 2p) це всього п’ять функцій.

\begin{minted}{python}
# STO-3G - найпростіший базис
mol = gto.M(atom='C 0 0 0', basis='sto-3g')
print(f'Кількість базисних функцій: {mol.nao_nr()}')
# Вивід: 5 (1s, 2s, 2px, 2py, 2pz)
\end{minted}

STO-3G означає, що кожна орбіталь Слейтера апроксимується сумою трьох гаусівських функцій.
Такі базиси часто використовують для тестів і навчальних цілей, але вони не забезпечують точних енергій ---
похибка порівняно з великими базисами може сягати десятків кДж/моль.

%% --------------------------------------------------------
\subsubsection{Валентно-розчеплені базиси}
%% --------------------------------------------------------

Більш точні обчислення вимагають \textbf{розщеплення валентних орбіталей},
щоб кожна з них могла гнучко адаптуватися під різні типи хімічних зв’язків.
Так з’являються базиси типу \texttt{6-31G}, \texttt{6-311G} тощо.


\inputcode{ValenceSplitBasisExample.py}


Позначення \texttt{6-31G} читається так:
\begin{itemize}
\item 6 гаусів використовуються для опису внутрішніх орбіталей (core);
\item валентна частина описується двома групами функцій: 3 і 1.
\end{itemize}

Додаткові символи мають такі значення:
\begin{itemize}
\item \texttt{*} --- додає поляризаційні $d$-функції на важких атомах;
\item \texttt{**} --- додає $d$-функції на важких і $p$-функції на водні атоми.
\end{itemize}

Ці функції дозволяють орбіталям деформуватися під дією хімічного оточення ---
завдяки цьому значно поліпшується опис зв’язків та дипольних моментів.

%% --------------------------------------------------------
\subsubsection{Кореляційно-послідовні базиси}
%% --------------------------------------------------------

Для кореляційних методів (MP2, CCSD, CI тощо) часто використовують \textbf{сімейство Dunning’а} ---
\texttt{cc-pVXZ}, де X = D, T, Q, 5, 6 (double-, triple-, quadruple-, quintuple-zeta).
Ці базиси систематично покращують опис хвильової функції й дозволяють проводити екстраполяцію до межі повного базису (CBS-limit).

\inputcode{CorrelationConsistentBasisExample.py}

Префікс \texttt{aug-} означає додавання \textbf{дифузних функцій} ---
функцій з малим експоненційним коефіцієнтом, що описують електрони, віддалені від ядра.
Такі базиси обов’язкові для аніонів, збуджених станів та слабких взаємодій (ван-дер-ваальсових систем).

%% --------------------------------------------------------
\subsubsection{def2 базиси}
%% --------------------------------------------------------

Базиси типу \texttt{def2} --- це сучасні розробки групи Карла Ахріхса,
оптимізовані для широкого спектру елементів (до лантаноїдів)
і дуже добре збалансовані для методів DFT.

\inputcode{Def2BasisExample.py}


Позначення:
\begin{itemize}
\item \texttt{SVP} --- Split-Valence Polarized (валентно-розщеплений, з поляризацією);
\item \texttt{TZVP} --- Triple-Zeta, більш гнучкий опис;
\item \texttt{QZVP} --- Quadruple-Zeta, для високоточної роботи.
\end{itemize}

Базиси \texttt{def2} часто використовуються разом з \textbf{ефективними псевдопотенціалами (ECP)},
які враховують релятивістські ефекти у важких елементах.

%% --------------------------------------------------------
\subsection{Вибір базисного набору: рекомендації}
%% --------------------------------------------------------

Вибір базису --- це завжди компроміс між швидкістю й точністю.
Загальні рекомендації наведено в Таблиці~\ref{tab:basis_recommendation}.

\begin{table}[h]
\centering\small
\caption{Рекомендовані базисні набори для різних задач}
\label{tab:basis_recommendation}
\begin{tblr}{
colspec={XXX},
row{1}={c,m, font=\bfseries},
}
\hline
{Задача} & {Базис} & {Коментар} \\
\hline
Тестові розрахунки & sto-3g, 3-21g & Дуже швидко, але грубо \\
Якісні результати & 6-31g*, 6-31g** & Оптимальний баланс точність/швидкість \\
Точні енергії & cc-pVTZ, cc-pVQZ & Для екстраполяції до межі базису \\
Аніони, збуджені стани & aug-cc-pVDZ & Потрібні дифузні функції \\
Важкі атоми & def2-TZVP & Добре враховує релятивістські ефекти \\
Дослідницькі розрахунки & cc-pVDZ & Надійний старт для систем середнього розміру \\
\hline
\end{tblr}
\end{table}

%% --------------------------------------------------------
\subsection{Власні базисні набори}
%% --------------------------------------------------------

Іноді потрібно створити власний базис (наприклад, для навчання або тестування гібридних моделей).
PySCF дозволяє явно задавати коефіцієнти та експоненти базисних функцій через \inlinecode{gto.basis.parse()}.


\inputcode{CustomBasisExample.py}


У цьому прикладі явно визначено два набори $s$-функцій із різними коефіцієнтами.
Так можна створювати спеціалізовані базиси для навчання або розширення стандартних наборів.

%% --------------------------------------------------------
\subsection{Комбінування базисів}
%% --------------------------------------------------------

PySCF підтримує \textbf{гібридні базиси} --- різні для різних атомів у тій самій системі.
Це корисно, коли потрібно зменшити обчислювальні витрати, наприклад,
використовуючи спрощений базис для водню, а розширений --- для важчих атомів.

\inputcode{CombiningBasesExample.py}

У результаті PySCF автоматично комбінує обидва базиси при побудові молекулярних орбіталей.

%% --------------------------------------------------------
\subsection{Інформація про базисний набір}
%% --------------------------------------------------------

Іноді потрібно дослідити, які саме функції використовуються у вибраному базисі ---
їхні типи, кількість та мітки. Для цього можна скористатися внутрішніми структурами об’єкта \inlinecode{Mole}.

\inputcode{BasisSetInfo.py}

Так можна отримати повну структуру базису --- скільки функцій кожного типу ($s$, $p$, $d$),
які індекси мають їхні атомні орбіталі, та як вони нумеруються в PySCF.
Ця інформація важлива при аналізі орбіталей, побудові щільності або інтегралів.



%% --------------------------------------------------------
\section{Симетрія в атомних розрахунках}
%% --------------------------------------------------------

Симетрія відіграє ключову роль у квантово-хімічних розрахунках. Вона дозволяє:
\begin{itemize}
    \item скоротити обчислювальні витрати (менше інтегралів та менші матриці),
    \item розпізнавати вироджені орбіталі та їх симетрійні властивості,
    \item аналізувати структуру електронних станів через іррепи (незвідні представлення),
    \item уникати «зайвих» розв’язків при самоузгодженні.
\end{itemize}

У PySCF симетрія автоматично враховується при побудові молекулярного об’єкта, якщо активувати опцію \inlinecode{symmetry=True}. Для атомів сферична симетрія апроксимується підгрупами типу \texttt{D2h}, що сумісні з декартовими координатами.

%% --------------------------------------------------------
\subsection{Точкові групи симетрії атомів}
%% --------------------------------------------------------

Ізольований атом у строгому сенсі має повну сферичну симетрію \( SO(3) \).
Однак у PySCF, через використання декартових базисних функцій, використовується одна з підгруп, зазвичай \texttt{D2h}.
Це дає змогу використовувати блокову структуру матриць і автоматично класифікувати орбіталі за іррепами.

\inputcode{SymmetryPointGroupsExample.py}

\textbf{Пояснення:}
\begin{itemize}
    \item \inlinecode{groupname} --- ідентифікатор підгрупи (наприклад, \texttt{D2h}, \texttt{C2v}, \texttt{Cs});
    \item \inlinecode{topgroup} --- вища група симетрії, до якої належить дана підгрупа.
\end{itemize}

%% --------------------------------------------------------
\subsection{Використання симетрії}
%% --------------------------------------------------------

Симетрія допомагає прискорити розрахунок, оскільки гамільтоніан та інші оператори блокуються відповідно до іррепів.
Тобто інтеграли між функціями з різних симетрій не обчислюються --- що значно зменшує обсяг роботи.

\inputcode{UsingSymmetryExample.py}

\textbf{Коментар:}
Різниця в енергіях практично нульова (обидва методи еквівалентні з фізичної точки зору),
але симетрійний розрахунок потребує значно менше часу і пам’яті.

%% --------------------------------------------------------
\subsection{Симетрія орбіталей}
%% --------------------------------------------------------

PySCF автоматично визначає симетрійні властивості орбіталей після розрахунку.
Це особливо корисно для аналізу заповнених і віртуальних рівнів, побудови діаграм енергетичних рівнів та порівняння з експериментом.

\inputcode{OrbitalSymmetryExample.py}

\textbf{Коментарі:}
\begin{itemize}
    \item \inlinecode{mol.irrep\_name} --- список назв іррепів\footnote{\textbf{Незвідне представлення (irrep)} --- фундаментальне поняття теорії груп, що описує, як функція (зокрема молекулярна орбіталь) трансформується під дією операцій симетрії молекули.
    Кожне ірредуцибельне представлення відповідає певному типу симетрії: наприклад, для групи $C_{2v}$ це $A_1$, $A_2$, $B_1$, $B_2$, а для групи $D_{2h}$ --- $A_g$, $B_{1g}$, $B_{2g}$, $B_{3g}$, $A_u$, $B_{1u}$, $B_{2u}$, $B_{3u}$.
    Всі орбіталі, що належать до одного й того ж irrep, мають однакову симетрію і можуть змішуватися між собою, тоді як орбіталі різних \texttt{irrep} не взаємодіють.};
    \item \inlinecode{mol.symm\_orb} --- матриці симетричних орбіталей;
    \item \inlinecode{label\_orb\_symm()} --- функція, що відображає орбіталі у відповідні іррепи;
    \item \inlinecode{get\_orbsym()} --- отримує симетрії молекулярних орбіталей з урахуванням побудованих коефіцієнтів.
\end{itemize}

Це дає змогу, наприклад, визначити які орбіталі мають однакову симетрію, а які не взаємодіють між собою.

%% --------------------------------------------------------
\subsection{Коли вимикати симетрію}
%% --------------------------------------------------------

Хоча симетрія зазвичай корисна, існують ситуації, коли її слід \textbf{вимкнути}:

\begin{itemize}
    \item При моделюванні \textbf{збуджених станів}, які порушують симетрію основного стану.
    \item При побудові \textbf{поверхонь потенційної енергії (PES)}, де геометрія змінюється і симетрія зникає.
    \item Якщо виникають \textbf{проблеми з конвергенцією} --- часто через жорсткі симетрійні обмеження.
    \item Коли необхідно вручну \textbf{змінювати орбіталі} або аналізувати змішування між різними симетріями.
\end{itemize}

У таких випадках достатньо задати:
\begin{minted}{python}
mol = gto.M(atom='...', basis='...', symmetry=False)
\end{minted}

\textbf{Підсумок:}
Використання симетрії --- це не лише «оптимізація швидкості», а й \textbf{фізично обґрунтований підхід},
що дозволяє зрозуміти структуру електронних рівнів, виродження та природу хімічних зв’язків.


%% ========================================================
\section{Спін та мультиплетність}
%% ========================================================

%% --------------------------------------------------------
\subsection{Визначення спінового стану}
%% --------------------------------------------------------

У квантовій хімії поняття спіну має фундаментальне значення.
Кожен електрон характеризується спіном $s = \frac{1}{2}$, тобто він може перебувати в одному з двох можливих спінових станів --- <<вгору>> ($\alpha$) або <<вниз>> ($\beta$).

Для багаточастинкової системи повний спін $S$ визначається як векторна сума спінів усіх електронів. У більшості практичних розрахунків нас цікавить тільки величина $S$ (а не його напрям).

В PySCF параметр \inlinecode{spin} задає величину $2S$, тобто різницю між кількістю $\alpha$- та $\beta$-електронів:
\begin{equation}
2S = N_\alpha - N_\beta
\end{equation}

Звідси:
\[
S = \frac{N_\alpha - N_\beta}{2}, \quad
M = 2S + 1
\]
де $M$ --- мультиплетність (кількість можливих орієнтацій спіну системи в магнітному полі).

\begin{itemize}
  \item $S = 0$ $\Rightarrow$ синглет ($M=1$)
  \item $S = \frac{1}{2}$ $\Rightarrow$ дублет ($M=2$)
  \item $S = 1$ $\Rightarrow$ триплет ($M=3$)
  \item $S = \frac{3}{2}$ $\Rightarrow$ квартет ($M=4$)
\end{itemize}

\inputcode{SpinExamples.py}

Цей код створює атомні молекули з різними значеннями параметра \inlinecode{spin}.
В об’єкті \inlinecode{mol.nelec} PySCF зберігає кортеж $(N_\alpha, N_\beta)$, що дозволяє контролювати спінову структуру системи.

%% --------------------------------------------------------
\subsection{Розподіл альфа- та бета-електронів}
%% --------------------------------------------------------

У багатоспінових системах важливо знати, як електрони розподілені за спіновими підрівнями.
В PySCF ця інформація визначається автоматично на основі параметра \inlinecode{spin}, однак її можна перевірити вручну.

\inputcode{PrintElectronConfig.py}

Ця функція показує, як саме PySCF обчислює кількість $\alpha$- та $\beta$-електронів.
Наприклад, для нейтрального атома кисню ($Z=8$) маємо 8 електронів.
При $2S=2$ отримаємо:
\[
N_\alpha = 5,\quad N_\beta = 3
\]
тобто два неспарені електрони --- саме це відповідає триплетному стану (${}^3P$).

%% --------------------------------------------------------
\subsection{Вибір правильного спіну}
%% --------------------------------------------------------

Необхідно завжди задавати правильний спін для основного стану атома або молекули, інакше \texttt{SCF}-процедура може не збігатися або дати фізично некоректний результат.

Правильне значення $S$ визначається на основі \emph{правил Хунда}:
\begin{enumerate}
\item Електрони займають орбіталі так, щоб сумарний спін $S$ був максимальним.
\item Для даного $S$ максимізується орбітальний момент $L$.
\item  Для менш ніж напівзаповненої оболонки найнижчий рівень має $J = |L - S|$, а для більш ніж напівзаповненої --- $J = L + S$.
\end{enumerate}

Для атомів другого періоду ці правила дають такі основні стани:

\begin{table}[h]
\centering
\caption{Основні спінові стани атомів другого періоду}
\label{tab:ground_states}
\begin{tabular}{llccc}
\hline
\textbf{Атом} & \textbf{Конфігурація} & \textbf{Терм} & \textbf{S} & \textbf{2S} \\
\hline
Li & [He] 2s¹ & ²S & 1/2 & 1 \\
Be & [He] 2s² & ¹S & 0 & 0 \\
B  & [He] 2s² 2p¹ & ²P & 1/2 & 1 \\
C  & [He] 2s² 2p² & ³P & 1 & 2 \\
N  & [He] 2s² 2p³ & $^4$S & 3/2 & 3 \\
O  & [He] 2s² 2p$^4$ & ³P & 1 & 2 \\
F  & [He] 2s² 2p$^5$ & ²P & 1/2 & 1 \\
Ne & [He] 2s² 2p$^6$ & ¹S & 0 & 0 \\
\hline
\end{tabular}
\end{table}



%% --------------------------------------------------------
\subsection{Енергетичне підтвердження спінових станів}
%% --------------------------------------------------------

Нижче наведено код, який обчислює енергії атомів другого періоду для їхніх правильних спінових станів.
Для відкрито-оболонкових систем (\inlinecode{spin > 0}) використовується \texttt{UHF} (неспарені електрони),
а для синглетів (\inlinecode{spin = 0}) --- \texttt{RHF}.

\inputcode{EnergyConfirmation2ndPeriod.py}

Результати дозволяють перевірити, що обраний спіновий стан дійсно відповідає мінімуму енергії для даного атома.
Якщо спробувати змінити \inlinecode{spin}, наприклад для атома азоту задати \inlinecode{spin=1}, отримаємо енергію вищу на кілька десятків міліГартрі --- тобто триплет виявиться збудженим станом відносно правильного квартету.


%% --------------------------------------------------------
\subsection{Практичні зауваження}
%% --------------------------------------------------------

\begin{itemize}
  \item У PySCF спін задається \emph{на всю систему}, тому при моделюванні молекул потрібно враховувати сумарний спін усіх атомів.
  \item Для молекул із непарним числом електронів (\texttt{odd number of electrons}) \inlinecode{spin} завжди має бути непарним.
  \item Неправильно заданий спін часто призводить до \texttt{SCF not converged}.
  \item При використанні \texttt{DFT} (наприклад, \inlinecode{scf.UKS}) параметр \inlinecode{spin} також впливає на спінову поляризацію густини.
\end{itemize}


%%% ========================================================
%\section{Налаштування параметрів конвергенції}
%%% ========================================================
%
%Метод самозгодженого поля (SCF — Self-Consistent Field) є основним чисельним кроком у розрахунках Гартрі–Фока (HF) та функціоналу густини (DFT).
%Його мета — знайти хвильову функцію, яка узгоджена з власним потенціалом електронної густини.
%Однак SCF-процедура є ітераційною, і її збіжність може бути неочевидною, особливо для відкрито-оболонкових систем, перехідних металів або нестандартних базисів.
%
%Нижче наведено параметри та прийоми, які дозволяють контролювати й покращувати збіжність у PySCF.
%
%%% --------------------------------------------------------
%\subsection{Основні параметри SCF}
%%% --------------------------------------------------------
%
%Основні параметри визначають точність, стратегію прискорення та межі ітераційного процесу.
%У PySCF об’єкт \inlinecode{mf = scf.UHF(mol)} (чи \texttt{RHF/ROHF}) має низку атрибутів, що дозволяють тонко налаштовувати алгоритм SCF.
%
%
%\inputcode{SCFParametersExample.py}
%
%
%\paragraph{Коментар:}
%\begin{itemize}
%  \item \inlinecode{conv\_tol} — контролює точність енергії. Для атомів перехідних металів бажано знижувати до $10^{-10}$.
%  \item \inlinecode{max\_cycle} — якщо SCF не збігається за цей ліміт, програма припиняє обчислення.
%  \item \inlinecode{diis} (Direct Inversion in the Iterative Subspace) — найпоширеніший метод прискорення SCF.
%  \item \inlinecode{level\_shift} — зменшує змішування зайнятих і віртуальних орбіталей на ранніх ітераціях, стабілізуючи розв’язок.
%\end{itemize}
%
%%% --------------------------------------------------------
%\subsection{Початкове наближення}
%%% --------------------------------------------------------
%
%Початкова матриця густини визначає, з якого стану починається ітераційний процес.
%Від правильного вибору \inlinecode{init\_guess} часто залежить, чи збіжиться SCF взагалі.
%
%\inputcode{InitialGuessExample.py}
%
%\paragraph{Рекомендації:}
%\begin{itemize}
%  \item Для ізольованих атомів і відкритих систем — \inlinecode{atom}.
%  \item Для молекул середнього розміру — \inlinecode{minao}.
%  \item Для restart або більших базисів після попереднього розрахунку — \inlinecode{chkfile}.
%\end{itemize}
%
%%% --------------------------------------------------------
%\subsection{Робота з важкими випадками конвергенції}
%%% --------------------------------------------------------
%
%Деякі системи, особливо перехідні метали або радикали, можуть давати розбіжність SCF навіть за коректних параметрів.
%У таких випадках застосовують комбінацію стабілізаційних технік.
%
%\inputcode{HardConvergenceCases.py}
%
%\paragraph{Коментар:}
%\begin{itemize}
%  \item \textbf{Level shift} допомагає усунути коливання енергії при близьких за енергією орбіталях.
%  \item \textbf{Newton-Raphson SCF} — більш точний, але важчий чисельно метод; ефективний для металів.
%  \item \textbf{Fractional occupation} дозволяє часткове заселення орбіталей, корисно для вирівнювання густини при дегенерації.
%\end{itemize}
%
%%% --------------------------------------------------------
%\subsection{Моніторинг конвергенції}
%%% --------------------------------------------------------
%
%PySCF дозволяє відстежувати стан збіжності через callback-функції.
%Це корисно для аналізу енергетичного профілю і контролю похідних.
%
%\inputcode{ConvergenceMonitoring.py}
%
%\paragraph{Пояснення:}
%\begin{itemize}
%  \item \inlinecode{envs} — словник зі станом SCF (цикл, енергія, градієнт тощо).
%  \item \inlinecode{norm\_gorb} — норма матриці похідних (градiєнт SCF).
%  \item Моніторинг дозволяє оцінювати стабільність збіжності та спостерігати коливання енергії.
%\end{itemize}
%
%%% --------------------------------------------------------
%\subsection{Збереження та завантаження результатів}
%%% --------------------------------------------------------
%
%Після завершення SCF-обчислень результати можна зберегти у файл для подальшого використання.
%Це дозволяє виконувати розрахунки з більшими базисами, використовуючи попередню густину.
%
%\inputcode{SaveLoadResults.py}
%
%\paragraph{Поради:}
%\begin{itemize}
%  \item Для повторних розрахунків з більшими базисами або у DFT — \texttt{chkfile} з попереднього SCF значно пришвидшує збіжність.
%  \item Можна зберігати SCF-хвильову функцію атома і використовувати її як ініціалізацію для молекули.
%  \item Формат \texttt{.chk} — це двійковий HDF5-файл, який містить усі орбіталі, густини, енергії тощо.
%\end{itemize}


\section{Практичний приклад: комплексний аналіз атома}

Розглянемо повний приклад аналізу атома з використанням всіх описаних концепцій:

\inputcode{AtomComplexAnalisys.py}


%% ========================================================
\section{Корисні функції та методи}
%% ========================================================

%% --------------------------------------------------------
\subsection{Інформація про атом}
%% --------------------------------------------------------

\inputcode{AtomInfoExample.py}

%% --------------------------------------------------------
\subsection{Маніпуляції з базисом}
%% --------------------------------------------------------

\inputcode{BasisManipulations.py}

%% --------------------------------------------------------
\subsection{Енергетичні компоненти}
%% --------------------------------------------------------

\inputcode{EnergyComponents.py}

%% --------------------------------------------------------
\subsection{Резюме}
%% --------------------------------------------------------

\begin{itemize}
    \item \textbf{Клас Mole} --- центральний об'єкт, що містить всю інформацію про систему.
    \item \textbf{Базисні набори} --- від мінімальних (STO-3G) до великих (cc-pVQZ); вибір залежить від задачі та компромісу точність/вартість.
    \item \textbf{Симетрія} --- прискорює розрахунки, але може обмежувати гнучкість при спонтанному руйнуванні симетрії.
    \item \textbf{Спін} --- критичний параметр для правильного опису основного стану відкрито-оболонкових систем.
%    \item \textbf{Конвергенція} --- використовуйте DIIS, level-shift, Newton-Raphson або fractional occupation для стабілізації важких випадків.
\end{itemize}

%% --------------------------------------------------------
\subsection{Контрольні запитання}
%% --------------------------------------------------------

\begin{enumerate}
    \item Яка різниця між методами створення об'єкта Mole через \inlinecode{gto.M()} та покроково?
    \item Чому для атома Карбону у основному стані використовується \inlinecode{spin=2}?
    \item Коли слід використовувати дифузні функції (aug- базиси)?
    \item Що означає параметр \inlinecode{conv\_tol} і як він впливає на точність?
    \item Які методи початкового наближення найкраще підходять для атомів?
\end{enumerate}


%% --------------------------------------------------------
\subsection{Завдання для самостійної роботи}
%% --------------------------------------------------------

\begin{enumerate}
    \item Створіть функцію, яка автоматично визначає правильний спін для атомів першого та другого періодів.
    \item Порівняйте енергії атома Неону з різними базисними наборами (STO-3G, 6-31G, cc-pVDZ, cc-pVTZ) та побудуйте графік залежності енергії від розміру базису.
    \item Дослідіть вплив симетрії на швидкість розрахунку для атома Аргону: порівняйте час виконання з \inlinecode{symmetry=True} та \inlinecode{symmetry=False}.
    \item Обчисліть енергію іонізації атома Літію як різницю енергій Li та Li$^+$.
    \item Для атома Заліза (Fe) з різними спіновими станами (2S = 2, 4, 6) знайдіть, який стан має найнижчу енергію.
\end{enumerate}

У наступному розділі ми детально розглянемо метод Хартрі-Фока та його застосування до розрахунків атомів.