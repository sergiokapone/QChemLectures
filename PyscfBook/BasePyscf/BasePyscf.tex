% !TeX program = lualatex
% !TeX encoding = utf8
% !TeX spellcheck = uk_UA
% !TeX root =../PyscfBook.tex

%=========================================================
\Opensolutionfile{answer}[\currfilebase/\currfilebase-Answers]
\chapter{Базові об'єкти та поняття в PySCF}\label{\currfilebase}
%=========================================================

%% --------------------------------------------------------
\section{Молекулярний об'єкт (Mole)}
%% --------------------------------------------------------


%% --------------------------------------------------------
\subsection{Клас Mole --- серце PySCF}
%% --------------------------------------------------------

Клас \texttt{gto.Mole} є центральним об'єктом у бібліотеці \textbf{PySCF} (Python-based Simulations of Chemistry Framework).
Цей клас визначає і зберігає всю інформацію про атомну або молекулярну систему, яка необхідна для квантово-хімічних розрахунків.
Саме з нього починається будь-який проєкт у PySCF, адже всі інші модулі (SCF, DFT, MP2, CCSD тощо) працюють із вже побудованим об'єктом \texttt{Mole}.

Об’єкт \texttt{Mole} містить такі основні дані:
\begin{itemize}
    \item \textbf{Геометрію системи} --- координати атомів у просторі (в ангстремах або борах);
    \item \textbf{Базисний набір} --- набір функцій, на яких розкладаються молекулярні орбіталі;
    \item \textbf{Заряд системи} та \textbf{спін} (мультипліситет);
    \item \textbf{Інформацію про симетрію} (за потреби);
    \item \textbf{Одиниці вимірювання} (ангстреми, бори).
\end{itemize}

Таким чином, \texttt{Mole} виконує роль «серця» всієї програми --- воно зберігає стан квантової системи і передає цю інформацію до інших підсистем для проведення обчислень.

%% --------------------------------------------------------
\subsection{Створення об'єкта Mole}
%% --------------------------------------------------------

Існує два основні способи створення молекулярного об'єкта: або за допомогою скороченого конструктора, або покроково.
Обидва підходи рівноцінні за результатом, однак відрізняються стилем запису.

\paragraph{Метод 1: Використання конструктора M()}

Цей спосіб є найзручнішим для простих систем, коли всі параметри можна вказати безпосередньо при створенні об'єкта:

\begin{minted}{python}
from pyscf import gto

# Простий спосіб
mol = gto.M(
    atom='Li 0 0 0',
    basis='6-31g',
    charge=0,
    spin=1
)
\end{minted}

Тут:
\begin{itemize}
    \item \texttt{atom='Li 0 0 0'} --- визначає атом літію в координатах (0, 0, 0);
    \item \texttt{basis='6-31g'} --- вказує базисний набір для розрахунків;
    \item \texttt{charge=0} --- нейтральний атом;
    \item \texttt{spin=1} --- означає, що система має $2S = 1$, тобто один неспарений електрон.
\end{itemize}

Функція \texttt{gto.M()} автоматично створює об’єкт, налаштовує всі параметри та викликає \texttt{.build()}.

\paragraph{Метод 2: Покрокове налаштування}

Цей спосіб зручний для складних систем, де потрібно задати багато параметрів або змінювати їх під час роботи:

\begin{minted}{python}
from pyscf import gto

# Створення порожнього об'єкта
mol = gto.Mole()

# Налаштування параметрів
mol.atom = 'C 0 0 0'
mol.basis = 'cc-pvdz'
mol.charge = 0
mol.spin = 2  # Два неспарені електрони

# Завершення побудови (важливо!)
mol.build()
\end{minted}

\textbf{Важливо:} При використанні другого методу обов'язково викликати команду \texttt{mol.build()},
інакше PySCF не згенерує внутрішні структури (матриці, орбіталі, таблиці інтегралів тощо), необхідні для подальших розрахунків.

%% --------------------------------------------------------
\subsection{Основні атрибути об'єкта Mole}
%% --------------------------------------------------------

Після побудови об'єкта можна отримати детальну інформацію про систему.
Ось приклад, який демонструє найпоширеніші атрибути:

\begin{minted}{python}
from pyscf import gto

mol = gto.M(atom='O 0 0 0', basis='6-31g', spin=2)

# Інформація про систему
print(f'Кількість електронів: {mol.nelectron}')
print(f'Заряд: {mol.charge}')
print(f'Спін (2S): {mol.spin}')
print(f'Кількість базисних функцій: {mol.nao_nr()}')

# Альфа та бета електрони
print(f'Альфа електронів: {mol.nelec[0]}')
print(f'Бета електронів: {mol.nelec[1]}')

# Атомна структура
print(f'Кількість атомів: {mol.natm}')
print(f'Заряди ядер: {mol.atom_charges()}')

# Базисний набір
print(f'Назва базису: {mol.basis}')
\end{minted}

\noindent
Ці атрибути особливо важливі для перевірки, чи правильно задані всі вхідні параметри перед запуском складних обчислень.

\begin{itemize}
    \item \texttt{mol.nelectron} --- кількість електронів у системі;
    \item \texttt{mol.charge} --- сумарний заряд системи;
    \item \texttt{mol.spin} --- подвоєне значення спіну ($2S$);
    \item \texttt{mol.nao\_nr()} --- кількість базисних орбіталей (число функцій, які будуть використані в обчисленнях);
    \item \texttt{mol.nelec} --- кортеж \texttt{(n\_alpha, n\_beta)} з кількістю альфа- та бета-електронів;
    \item \texttt{mol.natm} --- кількість атомів у системі;
    \item \texttt{mol.atom\_charges()} --- масив ядерних зарядів;
    \item \texttt{mol.basis} --- опис обраного базисного набору.
\end{itemize}

\noindent
Типовий вивід програми для атома кисню:

\begin{minted}{bash}
Кількість електронів: 8
Заряд: 0
Спін (2S): 2
Кількість базисних функцій: 18
Альфа електронів: 5
Бета електронів: 3
Кількість атомів: 1
Заряди ядер: [8.]
Назва базису: 6-31g
\end{minted}

Такий вивід дозволяє переконатися, що система побудована коректно, а параметри відповідають фізичному змісту задачі.
Наприклад, у цьому випадку маємо нейтральний атом кисню ($Z=8$, $N_e=8$), у якого спін $S=1$ (два неспарені електрони).


Після побудови об’єкта \texttt{Mole} його можна передавати до будь-яких методів PySCF --- від найпростіших \texttt{SCF} до корельованих методів \texttt{CCSD}, \texttt{CASCI} та інших.
Тому розуміння структури і властивостей цього класу є ключем до ефективного використання всієї бібліотеки.


%% --------------------------------------------------------
\subsection{Визначення атома: різні способи}
%% --------------------------------------------------------

Визначення атома або атомів --- це перший крок при побудові квантово-хімічної моделі.
У PySCF координати та типи атомів можна задавати кількома способами.
Усі вони приводять до одного й того ж результату, тому вибір форми запису залежить лише від зручності.

\paragraph{Спосіб 1: Рядок}

Цей варіант є найпростішим і найчастіше використовується для одиночних атомів або малих систем.
Формат: \texttt{<атом> x y z}, де координати задаються в ангстремах за замовчуванням (або в борах, якщо \texttt{unit='Bohr'}).

\begin{minted}{python}
# Один атом
mol = gto.M(atom='Ne 0 0 0', basis='def2-svp')

# Можна використовувати атомний номер
mol = gto.M(atom='10 0 0 0', basis='def2-svp')  # 10 = Ne
\end{minted}

Як видно, PySCF дозволяє вказувати елемент як за його хімічним символом, так і за атомним номером.
У другому випадку він автоматично розпізнає елемент періодичної системи.

\paragraph{Спосіб 2: Список або кортеж}

Якщо потрібно задати кілька атомів, або якщо координати отримуються програмно (наприклад, з масиву),
зручно використовувати структуру даних типу \texttt{list} або \texttt{tuple}.
Кожен атом описується як пара: \texttt{[ім'я, (x, y, z)]}.

\begin{minted}{python}
# Використання списку
mol = gto.M(
    atom=[['Na', (0.0, 0.0, 0.0)]],
    basis='aug-cc-pvdz'
)

# Для декількох атомів (наприклад, для порівняння)
mol = gto.M(
    atom=[
        ['H', (0.0, 0.0, 0.0)],
        ['He', (5.0, 0.0, 0.0)]  # далеко один від одного
    ],
    basis='sto-3g'
)
\end{minted}

Така форма є більш універсальною --- вона дозволяє легко зчитувати геометрію з файлів,
генерувати координати циклом або будувати складні молекули.
Наприклад, молекула водню \texttt{H$_2$} може бути задана як:
\[
\texttt{atom = [['H', (0, 0, 0)], ['H', (0, 0, 0.74)]]}
\]
де відстань у 0.74 Å відповідає типовій довжині зв’язку H–H.

%% --------------------------------------------------------
\subsection{Робота з іонами}
%% --------------------------------------------------------

Клас \texttt{Mole} дозволяє легко моделювати заряджені системи --- катіони та аніони.
Для цього достатньо змінити параметр \texttt{charge}, який визначає сумарний заряд системи:
\[
Q = Z_\text{ядер} - N_\text{електронів}
\]

Крім того, слід відповідно скоригувати \texttt{spin}, який задає подвоєне значення спіну $2S$.
Для нейтральних атомів значення спіну зазвичай відповідає їхній електронній конфігурації.

\begin{minted}{python}
from pyscf import gto, scf

# Нейтральний атом Li
li_atom = gto.M(atom='Li 0 0 0', basis='6-31g', charge=0, spin=1)

# Катіон Li+ (втрачено 1 електрон)
li_cation = gto.M(atom='Li 0 0 0', basis='6-31g', charge=1, spin=0)

# Аніон Li- (додано 1 електрон)
li_anion = gto.M(atom='Li 0 0 0', basis='6-31g', charge=-1, spin=1)

print(f'Li:  {li_atom.nelectron} електронів')
print(f'Li+: {li_cation.nelectron} електронів')
print(f'Li-: {li_anion.nelectron} електронів')
\end{minted}

У цьому прикладі можна побачити, як зміна заряду впливає на кількість електронів:
\begin{itemize}
    \item Нейтральний атом \texttt{Li} має 3 електрони;
    \item Катіон \texttt{Li$^+$} --- 2 електрони (втратив один);
    \item Аніон \texttt{Li$^-$} --- 4 електрони (отримав додатковий).
\end{itemize}

Такі прості зміни параметрів дозволяють вивчати іонізаційні енергії, електронну спорідненість,
а також порівнювати властивості нейтральних і заряджених систем.

%% --------------------------------------------------------
\subsection{Налаштування вербальності виводу}
%% --------------------------------------------------------

PySCF має вбудований механізм керування докладністю текстового виводу (тобто "балакучістю" програми).
Це зручно, коли потрібно або бачити повну діагностику, або, навпаки, приховати проміжні повідомлення при пакетних розрахунках.

Рівень керується параметром \texttt{verbose}:
\[
\texttt{0 = тихо}, \quad
\texttt{4 = стандартно}, \quad
\texttt{9 = детально (debug)}
\]

\begin{minted}{python}
# verbose контролює кількість виводу
# 0 = мінімум, 4 = максимум (за замовчуванням), 9 = дебаг

mol = gto.M(
    atom='F 0 0 0',
    basis='cc-pvdz',
    verbose=4  # Детальний вивід
)

# Або налаштувати пізніше
mol.verbose = 0  # Тихий режим
mol.build()
\end{minted}

\noindent
У практиці рекомендується:
\begin{itemize}
    \item Використовувати \texttt{verbose=4} для навчальних цілей, щоб бачити хід побудови базису та інтегралів;
    \item Використовувати \texttt{verbose=0} або \texttt{1} при серійному запуску розрахунків на кластері, щоб уникнути перевантаження логів;
    \item Для діагностики чи налагодження коду --- \texttt{verbose=7-9}, що дає максимально деталізований вивід.
\end{itemize}

Таким чином, параметр \texttt{verbose} дозволяє зручно регулювати ступінь деталізації повідомлень під час обчислень,
роблячи роботу з PySCF більш контрольованою і зручною як для навчання, так і для автоматизованих досліджень.


%% --------------------------------------------------------
\section{Базисні набори для атомів}
%% --------------------------------------------------------


%% --------------------------------------------------------
\subsection{Типи базисних наборів}
%% --------------------------------------------------------

У методах квантової хімії атомні орбіталі представлені не аналітичними розв’язками рівняння Шредінгера,
а певними апроксимаціями --- \textbf{базисними функціями}.
Сукупність цих функцій для всіх атомів системи називається \textbf{базисним набором (basis set)}.

Базис задає, скільки функцій використовується для опису кожної орбіталі (1s, 2p, 3d, ...),
та яку форму вони мають (наприклад, гаусівські чи слейтерівські орбіталі).
Від вибору базисного набору залежить баланс між швидкістю розрахунку та точністю енергії.

У PySCF базис задається через параметр \texttt{basis='...'},
і можна використовувати як стандартні бібліотечні набори, так і власні, створені вручну.

%% --------------------------------------------------------
\subsubsection{Мінімальні базиси}
%% --------------------------------------------------------

Мінімальний базис --- це найпростіший опис, коли на кожну атомну орбіталь використовується рівно одна базисна функція.
Наприклад, для атома вуглецю (1s, 2s, 2p) це всього п’ять функцій.

\begin{minted}{python}
# STO-3G - найпростіший базис
mol = gto.M(atom='C 0 0 0', basis='sto-3g')
print(f'Кількість базисних функцій: {mol.nao_nr()}')
# Вивід: 5 (1s, 2s, 2px, 2py, 2pz)
\end{minted}

STO-3G означає, що кожна орбіталь Слейтера апроксимується сумою трьох гаусівських функцій.
Такі базиси часто використовують для тестів і навчальних цілей, але вони не забезпечують точних енергій ---
похибка порівняно з великими базисами може сягати десятків кДж/моль.

%% --------------------------------------------------------
\subsubsection{Валентно-розчеплені базиси}
%% --------------------------------------------------------

Більш точні обчислення вимагають \textbf{розщеплення валентних орбіталей},
щоб кожна з них могла гнучко адаптуватися під різні типи хімічних зв’язків.
Так з’являються базиси типу \texttt{6-31G}, \texttt{6-311G} тощо.

\begin{minted}{python}
# Сімейство Pople
mol_631g = gto.M(atom='N 0 0 0', basis='6-31g')
mol_6311g = gto.M(atom='N 0 0 0', basis='6-311g')

# З поляризаційними функціями
mol_631gd = gto.M(atom='N 0 0 0', basis='6-31g*')      # d на важких атомах
mol_631gdp = gto.M(atom='N 0 0 0', basis='6-31g**')    # d на важких, p на H

print(f'6-31g:   {mol_631g.nao_nr()} функцій')
print(f'6-31g*:  {mol_631gd.nao_nr()} функцій')
print(f'6-31g**: {mol_631gdp.nao_nr()} функцій')
\end{minted}

Позначення \texttt{6-31G} читається так:
\begin{itemize}
\item 6 гаусів використовуються для опису внутрішніх орбіталей (core);
\item валентна частина описується двома групами функцій: 3 і 1.
\end{itemize}

Додаткові символи мають такі значення:
\begin{itemize}
\item \texttt{*} --- додає поляризаційні $d$-функції на важких атомах;
\item \texttt{**} --- додає $d$-функції на важких і $p$-функції на водні атоми.
\end{itemize}

Ці функції дозволяють орбіталям деформуватися під дією хімічного оточення ---
завдяки цьому значно поліпшується опис зв’язків та дипольних моментів.

%% --------------------------------------------------------
\subsubsection{Кореляційно-послідовні базиси}
%% --------------------------------------------------------

Для кореляційних методів (MP2, CCSD, CI тощо) часто використовують \textbf{сімейство Dunning’а} ---
\texttt{cc-pVXZ}, де X = D, T, Q, 5, 6 (double-, triple-, quadruple-, quintuple-zeta).
Ці базиси систематично покращують опис хвильової функції й дозволяють проводити екстраполяцію до межі повного базису (CBS-limit).

\begin{minted}{python}
# cc-pVXZ сімейство (X = D, T, Q, 5, 6)
mol_dz = gto.M(atom='O 0 0 0', basis='cc-pvdz')   # Double-zeta
mol_tz = gto.M(atom='O 0 0 0', basis='cc-pvtz')   # Triple-zeta
mol_qz = gto.M(atom='O 0 0 0', basis='cc-pvqz')   # Quadruple-zeta

print(f'cc-pVDZ: {mol_dz.nao_nr()} функцій')
print(f'cc-pVTZ: {mol_tz.nao_nr()} функцій')
print(f'cc-pVQZ: {mol_qz.nao_nr()} функцій')

# Augmented версії (з дифузними функціями)
mol_adz = gto.M(atom='O 0 0 0', basis='aug-cc-pvdz')
print(f'aug-cc-pVDZ: {mol_adz.nao_nr()} функцій')
\end{minted}

Префікс \texttt{aug-} означає додавання \textbf{дифузних функцій} ---
функцій з малим експоненційним коефіцієнтом, що описують електрони, віддалені від ядра.
Такі базиси обов’язкові для аніонів, збуджених станів та слабких взаємодій (ван-дер-ваальсових систем).

%% --------------------------------------------------------
\subsubsection{def2 базиси}
%% --------------------------------------------------------

Базиси типу \texttt{def2} --- це сучасні розробки групи Карла Ахріхса,
оптимізовані для широкого спектру елементів (до лантаноїдів)
і дуже добре збалансовані для методів DFT.

\begin{minted}{python}
# Сімейство Ahlrichs
mol_svp = gto.M(atom='Si 0 0 0', basis='def2-svp')
mol_tzvp = gto.M(atom='Si 0 0 0', basis='def2-tzvp')
mol_qzvp = gto.M(atom='Si 0 0 0', basis='def2-qzvp')

print(f'def2-SVP:  {mol_svp.nao_nr()} функцій')
print(f'def2-TZVP: {mol_tzvp.nao_nr()} функцій')
print(f'def2-QZVP: {mol_qzvp.nao_nr()} функцій')
\end{minted}

Позначення:
- \texttt{SVP} --- Split-Valence Polarized (валентно-розщеплений, з поляризацією);
- \texttt{TZVP} --- Triple-Zeta, більш гнучкий опис;
- \texttt{QZVP} --- Quadruple-Zeta, для високоточної роботи.

Базиси \texttt{def2} часто використовуються разом з \textbf{ефективними псевдопотенціалами (ECP)},
які враховують релятивістські ефекти у важких елементах.

%% --------------------------------------------------------
\subsection{Вибір базисного набору: рекомендації}
%% --------------------------------------------------------

Вибір базису --- це завжди компроміс між швидкістю й точністю.
Загальні рекомендації наведено в Таблиці~\ref{tab:basis_recommendation}.

\begin{table}[h]
\centering\small
\caption{Рекомендовані базисні набори для різних задач}
\label{tab:basis_recommendation}
\begin{tblr}{
colspec={XXX},
row{1}={c,m, font=\bfseries},
}
\hline
{Задача} & {Базис} & {Коментар} \\
\hline
Тестові розрахунки & sto-3g, 3-21g & Дуже швидко, але грубо \\
Якісні результати & 6-31g*, 6-31g** & Оптимальний баланс точність/швидкість \\
Точні енергії & cc-pVTZ, cc-pVQZ & Для екстраполяції до межі базису \\
Аніони, збуджені стани & aug-cc-pVDZ & Потрібні дифузні функції \\
Важкі атоми & def2-TZVP & Добре враховує релятивістські ефекти \\
Дослідницькі розрахунки & cc-pVDZ & Надійний старт для систем середнього розміру \\
\hline
\end{tblr}
\end{table}

%% --------------------------------------------------------
\subsection{Власні базисні набори}
%% --------------------------------------------------------

Іноді потрібно створити власний базис (наприклад, для навчання або тестування гібридних моделей).
PySCF дозволяє явно задавати коефіцієнти та експоненти базисних функцій через \texttt{gto.basis.parse()}.

\begin{minted}{python}
from pyscf import gto

# Визначення базису для H (тільки s-функції)
mol = gto.M(
    atom='H 0 0 0',
    basis={
        'H': gto.basis.parse('''
            H    S
                 13.00773     0.019685
                  1.962079    0.137977
                  0.444529    0.478148
            H    S
                  0.1219492   1.000000
        ''')
    }
)

print(f'Власний базис: {mol.nao_nr()} функцій')
\end{minted}

У цьому прикладі явно визначено два набори $s$-функцій із різними коефіцієнтами.
Так можна створювати спеціалізовані базиси для навчання або розширення стандартних наборів.

%% --------------------------------------------------------
\subsection{Комбінування базисів}
%% --------------------------------------------------------

PySCF підтримує \textbf{гібридні базиси} --- різні для різних атомів у тій самій системі.
Це корисно, коли потрібно зменшити обчислювальні витрати, наприклад,
використовуючи спрощений базис для водню, а розширений --- для важчих атомів.

\begin{minted}{python}
# Для складних систем можна використовувати різні базиси
# (хоча для атомів це рідко потрібно)
mol = gto.M(
    atom='''
        H  0 0 0
        He 5 0 0
    ''',
    basis={
        'H': 'sto-3g',
        'He': 'cc-pvdz'
    }
)
\end{minted}

У результаті PySCF автоматично комбінує обидва базиси при побудові молекулярних орбіталей.

%% --------------------------------------------------------
\subsection{Інформація про базисний набір}
%% --------------------------------------------------------

Іноді потрібно дослідити, які саме функції використовуються у вибраному базисі ---
їхні типи, кількість та мітки. Для цього можна скористатися внутрішніми структурами об’єкта \texttt{Mole}.

\begin{minted}{python}
from pyscf import gto

mol = gto.M(atom='C 0 0 0', basis='6-31g')

# Детальна інформація
print('Базисні функції по типу:')
for atom_idx in range(mol.natm):
    symbol = mol.atom_symbol(atom_idx)
    print(f'\nАтом {symbol}:')

    # Кількість функцій кожного типу
    basis_atom = mol._basis[symbol]
    for shell in basis_atom:
        l_quantum = shell[0]  # Азимутальне квантове число
        n_contractions = len(shell[1:])

        shell_type = ['s', 'p', 'd', 'f', 'g'][l_quantum]
        print(f'  {shell_type}-тип: {n_contractions} contracted')

# Діапазони базисних функцій для атома
ao_labels = mol.ao_labels()
print(f'\nМітки базисних функцій:')
for i, label in enumerate(ao_labels):
    print(f'{i}: {label}')
\end{minted}

Так можна отримати повну структуру базису --- скільки функцій кожного типу ($s$, $p$, $d$),
які індекси мають їхні атомні орбіталі, та як вони нумеруються в PySCF.
Ця інформація важлива при аналізі орбіталей, побудові щільності або інтегралів.



%% --------------------------------------------------------
\section{Симетрія в атомних розрахунках}
%% --------------------------------------------------------

Симетрія відіграє ключову роль у квантово-хімічних розрахунках. Вона дозволяє:
\begin{itemize}
    \item скоротити обчислювальні витрати (менше інтегралів та менші матриці),
    \item розпізнавати вироджені орбіталі та їх симетрійні властивості,
    \item аналізувати структуру електронних станів через іррепи (незвідні представлення),
    \item уникати «зайвих» розв’язків при самоузгодженні.
\end{itemize}

У PySCF симетрія автоматично враховується при побудові молекулярного об’єкта, якщо активувати опцію \texttt{symmetry=True}. Для атомів сферична симетрія апроксимується підгрупами типу \texttt{D2h}, що сумісні з декартовими координатами.

%% --------------------------------------------------------
\subsection{Точкові групи симетрії атомів}
%% --------------------------------------------------------

Ізольований атом у строгому сенсі має повну сферичну симетрію \( SO(3) \).
Однак у PySCF, через використання декартових базисних функцій, використовується одна з підгруп, зазвичай \texttt{D2h}.
Це дає змогу використовувати блокову структуру матриць і автоматично класифікувати орбіталі за іррепами.

\begin{minted}{python}
from pyscf import gto

# Автоматичне визначення симетрії
mol = gto.M(
    atom='Ne 0 0 0',
    basis='cc-pvdz',
    symmetry=True  # Автоматичне визначення точкової групи
)

print(f'Точкова група: {mol.groupname}')
print(f'Топологічна група: {mol.topgroup}')

# Для атома результат, як правило: D2h або подібна підгрупа
\end{minted}

\textbf{Пояснення:}
\begin{itemize}
    \item \texttt{groupname} --- ідентифікатор підгрупи (наприклад, \texttt{D2h}, \texttt{C2v}, \texttt{Cs});
    \item \texttt{topgroup} --- вища група симетрії, до якої належить дана підгрупа.
\end{itemize}

%% --------------------------------------------------------
\subsection{Використання симетрії}
%% --------------------------------------------------------

Симетрія допомагає прискорити розрахунок, оскільки гамільтоніан та інші оператори блокуються відповідно до іррепів.
Тобто інтеграли між функціями з різних симетрій не обчислюються --- що значно зменшує обсяг роботи.

\begin{minted}{python}
from pyscf import gto, scf

# З симетрією (швидше, менше пам'яті)
mol_sym = gto.M(
    atom='Ar 0 0 0',
    basis='cc-pvdz',
    symmetry=True
)
mf_sym = scf.RHF(mol_sym)
e_sym = mf_sym.kernel()

# Без симетрії
mol_nosym = gto.M(
    atom='Ar 0 0 0',
    basis='cc-pvdz',
    symmetry=False
)
mf_nosym = scf.RHF(mol_nosym)
e_nosym = mf_nosym.kernel()

print(f'З симетрією:  {e_sym:.8f} Ha')
print(f'Без симетрії: {e_nosym:.8f} Ha')
print(f'Різниця: {abs(e_sym - e_nosym):.2e} Ha')
\end{minted}

\textbf{Коментар:}
Різниця в енергіях практично нульова (обидва методи еквівалентні з фізичної точки зору),
але симетрійний розрахунок потребує значно менше часу і пам’яті.

%% --------------------------------------------------------
\subsection{Симетрія орбіталей}
%% --------------------------------------------------------

PySCF автоматично визначає симетрійні властивості молекулярних орбіталей після розрахунку.
Це особливо корисно для аналізу заповнених і віртуальних рівнів, побудови діаграм енергетичних рівнів та порівняння з експериментом.

\begin{minted}{python}
from pyscf import gto, scf

mol = gto.M(
    atom='N 0 0 0',
    basis='cc-pvdz',
    spin=3,  # Основний стан ⁴S
    symmetry=True
)

mf = scf.UHF(mol)
mf.kernel()

# Орбітальна симетрія
if mol.symmetry:
    orbsym = scf.hf_symm.get_orbsym(mol, mf.mo_coeff[0])
    from pyscf.symm import label_orb_symm

    labels = label_orb_symm(mol, mol.irrep_name, mol.symm_orb,
                           mf.mo_coeff[0])

    print('\nСиметрія заповнених орбіталей (альфа):')
    for i in range(mol.nelec[0]):
        print(f'  MO {i+1}: {labels[i]}')
\end{minted}

\textbf{Коментарі:}
\begin{itemize}
    \item \texttt{mol.irrep\_name} --- список назв іррепів (наприклад, \texttt{Ag}, \texttt{B1u} тощо);
    \item \texttt{mol.symm\_orb} --- матриці симетричних орбіталей;
    \item \texttt{label\_orb\_symm()} --- функція, що відображає орбіталі у відповідні іррепи;
    \item \texttt{get\_orbsym()} --- отримує симетрії молекулярних орбіталей з урахуванням побудованих коефіцієнтів.
\end{itemize}

Це дає змогу, наприклад, визначити які орбіталі мають однакову симетрію, а які не взаємодіють між собою.

%% --------------------------------------------------------
\subsection{Коли вимикати симетрію}
%% --------------------------------------------------------

Хоча симетрія зазвичай корисна, існують ситуації, коли її слід \textbf{вимкнути}:

\begin{itemize}
    \item При моделюванні \textbf{збуджених станів}, які порушують симетрію основного стану.
    \item При побудові \textbf{поверхонь потенційної енергії (PES)}, де геометрія змінюється і симетрія зникає.
    \item Якщо виникають \textbf{проблеми з конвергенцією} --- часто через жорсткі симетрійні обмеження.
    \item Коли необхідно вручну \textbf{змінювати орбіталі} або аналізувати змішування між різними симетріями.
\end{itemize}

У таких випадках достатньо задати:
\begin{minted}{python}
mol = gto.M(atom='...', basis='...', symmetry=False)
\end{minted}

\textbf{Підсумок:}
Використання симетрії --- це не лише «оптимізація швидкості», а й \textbf{фізично обґрунтований підхід},
що дозволяє зрозуміти структуру електронних рівнів, виродження та природу хімічних зв’язків.


%% ========================================================
\section{Спін та мультиплетність}
%% ========================================================

%% --------------------------------------------------------
\subsection{Визначення спінового стану}
%% --------------------------------------------------------

У квантовій хімії поняття спіну має фундаментальне значення.
Кожен електрон характеризується спіном $s = \frac{1}{2}$, тобто він може перебувати в одному з двох можливих спінових станів --- ``вгору'' ($\alpha$) або ``вниз'' ($\beta$).

Для багаточастинкової системи повний спін $S$ визначається як векторна сума спінів усіх електронів. У більшості практичних розрахунків нас цікавить тільки величина $S$ (а не його напрям).

В \texttt{PySCF} параметр \texttt{spin} задає величину $2S$, тобто різницю між кількістю $\alpha$- та $\beta$-електронів:
\begin{equation}
2S = N_\alpha - N_\beta
\end{equation}

Звідси:
\[
S = \frac{N_\alpha - N_\beta}{2}, \quad
M = 2S + 1
\]
де $M$ --- мультиплетність (кількість можливих орієнтацій спіну системи в магнітному полі).

\begin{itemize}
  \item $S = 0$ $\Rightarrow$ синглет ($M=1$)
  \item $S = \frac{1}{2}$ $\Rightarrow$ дублет ($M=2$)
  \item $S = 1$ $\Rightarrow$ триплет ($M=3$)
  \item $S = \frac{3}{2}$ $\Rightarrow$ квартет ($M=4$)
\end{itemize}

%% Приклади для окремих атомів
\begin{minted}{python}
from pyscf import gto

# Атом H: S=1/2, 2S=1, дублет (M=2)
h = gto.M(atom='H 0 0 0', basis='cc-pvdz', spin=1)

# Атом He: S=0, 2S=0, синглет (M=1)
he = gto.M(atom='He 0 0 0', basis='cc-pvdz', spin=0)

# Атом O: основний стан ³P, S=1, 2S=2, триплет (M=3)
o = gto.M(atom='O 0 0 0', basis='cc-pvdz', spin=2)

# Атом N: основний стан ⁴S, S=3/2, 2S=3, квартет (M=4)
n = gto.M(atom='N 0 0 0', basis='cc-pvdz', spin=3)

print(f'H:  {h.nelec}, 2S={h.spin}, M={h.spin+1}')
print(f'He: {he.nelec}, 2S={he.spin}, M={he.spin+1}')
print(f'O:  {o.nelec}, 2S={o.spin}, M={o.spin+1}')
print(f'N:  {n.nelec}, 2S={n.spin}, M={n.spin+1}')
\end{minted}

Цей код створює атомні молекули з різними значеннями параметра \texttt{spin}.
В об’єкті \texttt{mol.nelec} PySCF зберігає кортеж $(N_\alpha, N_\beta)$, що дозволяє контролювати спінову структуру системи.

%% --------------------------------------------------------
\subsection{Розподіл альфа- та бета-електронів}
%% --------------------------------------------------------

У багатоспінових системах важливо знати, як електрони розподілені за спіновими підрівнями.
В \texttt{PySCF} ця інформація визначається автоматично на основі параметра \texttt{spin}, однак її можна перевірити вручну.

\begin{minted}{python}
from pyscf import gto

def print_electron_config(atom_symbol, charge=0, spin=0):
    mol = gto.M(
        atom=f'{atom_symbol} 0 0 0',
        basis='sto-3g',
        charge=charge,
        spin=spin
    )

    n_alpha, n_beta = mol.nelec
    print(f'{atom_symbol} (charge={charge}, 2S={spin}):')
    print(f'  Всього електронів: {mol.nelectron}')
    print(f'  α-електронів: {n_alpha}')
    print(f'  β-електронів: {n_beta}')
    print(f'  Неспарених: {n_alpha - n_beta}\n')

# Приклади
print_electron_config('Li', charge=0, spin=1)    # Li (2s¹)
print_electron_config('C',  charge=0, spin=2)    # C (³P)
print_electron_config('O',  charge=0, spin=2)    # O (³P)
print_electron_config('O',  charge=-1, spin=1)   # O⁻ (дублет)
\end{minted}

Ця функція показує, як саме \texttt{PySCF} обчислює кількість $\alpha$- та $\beta$-електронів.
Наприклад, для нейтрального атома кисню ($Z=8$) маємо 8 електронів.
При $2S=2$ отримаємо:
\[
N_\alpha = 5,\quad N_\beta = 3
\]
тобто два неспарені електрони --- саме це відповідає триплетному стану (${}^3P$).

%% --------------------------------------------------------
\subsection{Вибір правильного спіну}
%% --------------------------------------------------------

Необхідно завжди задавати правильний спін для основного стану атома або молекули, інакше \texttt{SCF}-процедура може не збігатися або дати фізично некоректний результат.

Правильне значення $S$ визначається на основі **правил Хунда**:
1. Електрони займають орбіталі так, щоб сумарний спін $S$ був максимальним.
2. Для даного $S$ максимізується орбітальний момент $L$.
3. Для менш ніж напівзаповненої оболонки найнижчий рівень має $J = |L - S|$, а для більш ніж напівзаповненої --- $J = L + S$.

Для атомів другого періоду ці правила дають такі основні стани:

\begin{table}[h]
\centering
\caption{Основні спінові стани атомів другого періоду}
\label{tab:ground_states}
\begin{tabular}{llccc}
\hline
\textbf{Атом} & \textbf{Конфігурація} & \textbf{Терм} & \textbf{S} & \textbf{2S} \\
\hline
Li & [He] 2s¹ & ²S & 1/2 & 1 \\
Be & [He] 2s² & ¹S & 0 & 0 \\
B  & [He] 2s² 2p¹ & ²P & 1/2 & 1 \\
C  & [He] 2s² 2p² & ³P & 1 & 2 \\
N  & [He] 2s² 2p³ & $^4$S & 3/2 & 3 \\
O  & [He] 2s² 2p$^4$ & ³P & 1 & 2 \\
F  & [He] 2s² 2p$^5$ & ²P & 1/2 & 1 \\
Ne & [He] 2s² 2p$^6$ & ¹S & 0 & 0 \\
\hline
\end{tabular}
\end{table}



%% --------------------------------------------------------
\subsection{Енергетичне підтвердження спінових станів}
%% --------------------------------------------------------

Нижче наведено код, який обчислює енергії атомів другого періоду для їхніх правильних спінових станів.
Для відкрито-оболонкових систем (\texttt{spin > 0}) використовується \texttt{UHF} (неспарені електрони),
а для синглетів (\texttt{spin = 0}) --- \texttt{RHF}.

\begin{minted}{python}
from pyscf import gto, scf

# Правильні спінові стани для другого періоду
atoms_2nd_period = [
    ('Li', 1), ('Be', 0), ('B', 1), ('C', 2),
    ('N', 3), ('O', 2), ('F', 1), ('Ne', 0)
]

print('Основні стани атомів другого періоду:\n')
for symbol, spin in atoms_2nd_period:
    mol = gto.M(
        atom=f'{symbol} 0 0 0',
        basis='6-31g',
        spin=spin
    )
    mf = scf.UHF(mol) if spin > 0 else scf.RHF(mol)
    mf.verbose = 0
    energy = mf.kernel()

    mult = spin + 1
    print(f'{symbol:2s}: 2S={spin}, M={mult}, E={energy:12.6f} Ha')
\end{minted}

Результати дозволяють перевірити, що обраний спіновий стан дійсно відповідає мінімуму енергії для даного атома.
Якщо спробувати змінити \texttt{spin}, наприклад для атома азоту задати \texttt{spin=1}, отримаємо енергію вищу на кілька десятків міліГартрі --- тобто триплет виявиться збудженим станом відносно правильного квартету.


%% --------------------------------------------------------
\subsection{Практичні зауваження}
%% --------------------------------------------------------

\begin{itemize}
  \item У PySCF спін задається \emph{на всю систему}, тому при моделюванні молекул потрібно враховувати сумарний спін усіх атомів.
  \item Для молекул із непарним числом електронів (\texttt{odd number of electrons}) \texttt{spin} завжди має бути непарним.
  \item Неправильно заданий спін часто призводить до \texttt{SCF not converged}.
  \item При використанні \texttt{DFT} (наприклад, \texttt{scf.UKS}) параметр \texttt{spin} також впливає на спінову поляризацію густини.
\end{itemize}


%% ========================================================
\section{Налаштування параметрів конвергенції}
%% ========================================================

Метод самозгодженого поля (SCF — Self-Consistent Field) є основним чисельним кроком у розрахунках Гартрі–Фока (HF) та функціоналу густини (DFT).
Його мета — знайти хвильову функцію, яка узгоджена з власним потенціалом електронної густини.
Однак SCF-процедура є ітераційною, і її збіжність може бути неочевидною, особливо для відкрито-оболонкових систем, перехідних металів або нестандартних базисів.

Нижче наведено параметри та прийоми, які дозволяють контролювати й покращувати збіжність у PySCF.

%% --------------------------------------------------------
\subsection{Основні параметри SCF}
%% --------------------------------------------------------

Основні параметри визначають точність, стратегію прискорення та межі ітераційного процесу.
У PySCF об’єкт \texttt{mf = scf.UHF(mol)} (чи \texttt{RHF/ROHF}) має низку атрибутів, що дозволяють тонко налаштовувати алгоритм SCF.

\begin{minted}{python}
from pyscf import gto, scf

mol = gto.M(atom='Fe 0 0 0', basis='def2-svp', spin=4)
mf = scf.UHF(mol)

# Критерій конвергенції (допустима різниця енергії між ітераціями)
mf.conv_tol = 1e-10  # За замовчуванням 1e-9

# Максимальна кількість ітерацій SCF
mf.max_cycle = 100   # За замовчуванням 50

# Використання DIIS (Pulay mixing) для прискорення збіжності
mf.diis = True       # Активовано за замовчуванням
mf.diis_space = 8    # Розмір DIIS-простору (типово 6–8)

# Level shift — підйом незайнятих орбіталей для стабілізації
mf.level_shift = 0.5  # У Hartree, типово 0.3–1.0 для важких випадків

energy = mf.kernel()
\end{minted}

\paragraph{Коментар:}
\begin{itemize}
  \item \textbf{conv\_tol} — контролює точність енергії. Для атомів перехідних металів бажано знижувати до $10^{-10}$.
  \item \textbf{max\_cycle} — якщо SCF не збігається за цей ліміт, програма припиняє обчислення.
  \item \textbf{DIIS} (Direct Inversion in the Iterative Subspace) — найпоширеніший метод прискорення SCF.
  \item \textbf{level\_shift} — зменшує змішування зайнятих і віртуальних орбіталей на ранніх ітераціях, стабілізуючи розв’язок.
\end{itemize}

%% --------------------------------------------------------
\subsection{Початкове наближення}
%% --------------------------------------------------------

Початкова матриця густини визначає, з якого стану починається ітераційний процес.
Від правильного вибору \texttt{init\_guess} часто залежить, чи збіжиться SCF взагалі.

\begin{minted}{python}
from pyscf import gto, scf

mol = gto.M(atom='Cr 0 0 0', basis='cc-pvdz', spin=6)
mf = scf.UHF(mol)

# Метод 1: Hcore (за замовчуванням)
mf.init_guess = 'hcore'  # Використання Гамільтоніана ядра

# Метод 2: Мінімальний базис (розширене наближення)
mf.init_guess = 'minao'

# Метод 3: Атомні густини (оптимально для атомів та іонів)
mf.init_guess = 'atom'

# Метод 4: 1e guess (використання лише одноелектронних інтегралів)
mf.init_guess = '1e'

# Метод 5: З попереднього файлу (для restart)
# mf.init_guess = 'chkfile'
# mf.chkfile = 'previous_calc.chk'

energy = mf.kernel()
\end{minted}

\paragraph{Рекомендації:}
\begin{itemize}
  \item Для ізольованих атомів і відкритих систем — \texttt{atom}.
  \item Для молекул середнього розміру — \texttt{minao}.
  \item Для restart або більших базисів після попереднього розрахунку — \texttt{chkfile}.
\end{itemize}

%% --------------------------------------------------------
\subsection{Робота з важкими випадками конвергенції}
%% --------------------------------------------------------

Деякі системи, особливо перехідні метали або радикали, можуть давати розбіжність SCF навіть за коректних параметрів.
У таких випадках застосовують комбінацію стабілізаційних технік.

\begin{minted}{python}
from pyscf import gto, scf
import numpy as np

mol = gto.M(atom='Mn 0 0 0', basis='def2-tzvp', spin=5)
mf = scf.UHF(mol)

# --- Стратегія 1: Level shift
mf.level_shift = 0.3
mf.max_cycle = 100

try:
    energy = mf.kernel()
except:
    print('Не конвергувало з level shift')

# --- Стратегія 2: Newton-Raphson SCF (другий порядок)
if not mf.converged:
    mf = mf.newton()  # Перехід до SCF другого порядку
    energy = mf.kernel()

# --- Стратегія 3: Fractional occupation (часткове заселення)
from pyscf import scf
mf = scf.UHF(mol)
mf = scf.addons.frac_occ(mf)
energy = mf.kernel()

print(f'Фінальна енергія: {energy:.8f} Ha')
print(f'Конвергувало: {mf.converged}')
\end{minted}

\paragraph{Коментар:}
\begin{itemize}
  \item \textbf{Level shift} допомагає усунути коливання енергії при близьких за енергією орбіталях.
  \item \textbf{Newton-Raphson SCF} — більш точний, але важчий чисельно метод; ефективний для металів.
  \item \textbf{Fractional occupation} дозволяє часткове заселення орбіталей, корисно для вирівнювання густини при дегенерації.
\end{itemize}

%% --------------------------------------------------------
\subsection{Моніторинг конвергенції}
%% --------------------------------------------------------

PySCF дозволяє відстежувати стан збіжності через callback-функції.
Це корисно для аналізу енергетичного профілю і контролю похідних.

\begin{minted}{python}
from pyscf import gto, scf

mol = gto.M(atom='V 0 0 0', basis='cc-pvdz', spin=3)
mf = scf.UHF(mol)

# Callback для моніторингу збіжності
def monitor(envs):
    cycle = envs['cycle']
    e_tot = envs['e_tot']
    norm_gorb = envs['norm_gorb']
    print(f'Cycle {cycle:2d}: E={e_tot:.8f}, |grad|={norm_gorb:.2e}')

mf.callback = monitor
energy = mf.kernel()

# Після завершення:
print(f'\nФінальна енергія: {energy:.8f} Ha')
print(f'Число ітерацій: {mf.iterations}')
print(f'Норма градієнта: {mf.scf_summary["norm_gorb"]:.2e}')
\end{minted}

\paragraph{Пояснення:}
\begin{itemize}
  \item \texttt{envs} — словник зі станом SCF (цикл, енергія, градієнт тощо).
  \item \texttt{norm\_gorb} — норма матриці похідних (градiєнт SCF).
  \item Моніторинг дозволяє оцінювати стабільність збіжності та спостерігати коливання енергії.
\end{itemize}

%% --------------------------------------------------------
\subsection{Збереження та завантаження результатів}
%% --------------------------------------------------------

Після завершення SCF-обчислень результати можна зберегти у файл для подальшого використання.
Це дозволяє виконувати розрахунки з більшими базисами, використовуючи попередню густину.

\begin{minted}{python}
from pyscf import gto, scf, lib

mol = gto.M(atom='Cu 0 0 0', basis='def2-tzvp', spin=1)
mf = scf.UHF(mol)

# Збереження у checkpoint файл
mf.chkfile = 'cu_atom.chk'
energy = mf.kernel()

# Завантаження результатів з файлу
mol2 = lib.chkfile.load_mol('cu_atom.chk')
mf2 = scf.UHF(mol2)
mf2.__dict__.update(lib.chkfile.load('cu_atom.chk', 'scf'))

print('Завантажена енергія:', mf2.e_tot)

# Використання як початкового наближення для нового базису
mol3 = gto.M(atom='Cu 0 0 0', basis='def2-qzvp', spin=1)
mf3 = scf.UHF(mol3)
mf3.init_guess = 'chkfile'
mf3.chkfile = 'cu_atom.chk'
energy3 = mf3.kernel()
\end{minted}

\paragraph{Поради:}
\begin{itemize}
  \item Для повторних розрахунків з більшими базисами або у DFT — \texttt{chkfile} з попереднього SCF значно пришвидшує збіжність.
  \item Можна зберігати SCF-хвильову функцію атома і використовувати її як ініціалізацію для молекули.
  \item Формат \texttt{.chk} — це двійковий HDF5-файл, який містить усі орбіталі, густини, енергії тощо.
\end{itemize}


\section{Практичний приклад: комплексний аналіз атома}

Розглянемо повний приклад аналізу атома з використанням всіх описаних концепцій:

\begin{minted}{python}
from pyscf import gto, scf, lib
import numpy as np

def analyze_atom(symbol, charge=0, spin=None, basis='cc-pvdz'):
    """
    Комплексний аналіз атома

    Parameters:
    -----------
    symbol : str
        Символ атома
    charge : int
        Заряд (0 для нейтрального)
    spin : int
        2S (якщо None, визначається автоматично)
    basis : str
        Базисний набір
    """

    print(f'\n{"="*60}')
    print(f'Аналіз атома {symbol} (charge={charge}, basis={basis})')
    print(f'{"="*60}\n')

    # Створення молекулярного об'єкта
    mol = gto.M(
        atom=f'{symbol} 0 0 0',
        basis=basis,
        charge=charge,
        spin=spin if spin is not None else 0,
        symmetry=True,
        verbose=4
    )

    # Інформація про систему
    print(f'Кількість електронів: {mol.nelectron}')
    print(f'α-електронів: {mol.nelec[0]}')
    print(f'β-електронів: {mol.nelec[1]}')
    print(f'Спін (2S): {mol.spin}')
    print(f'Мультиплетність: {mol.spin + 1}')
    print(f'Базисних функцій: {mol.nao_nr()}')
    print(f'Точкова група: {mol.groupname}\n')

    # Вибір методу SCF
    if mol.spin == 0:
        mf = scf.RHF(mol)
        method_name = 'RHF'
    else:
        mf = scf.UHF(mol)
        method_name = 'UHF'

    # Налаштування параметрів
    mf.conv_tol = 1e-10
    mf.max_cycle = 100
    mf.init_guess = 'atom'

    # Розрахунок
    print(f'Запуск {method_name} розрахунку...\n')
    energy = mf.kernel()

    if not mf.converged:
        print('Не конвергувало! Спроба Newton-Raphson...')
        mf = mf.newton()
        energy = mf.kernel()

    # Результати
    print(f'\n{"="*60}')
    print(f'РЕЗУЛЬТАТИ')
    print(f'{"="*60}')
    print(f'Енергія: {energy:.10f} Ha')
    print(f'Енергія: {energy * 27.211386:.6f} eV')
    print(f'Конвергувало: {mf.converged}')

    # Аналіз орбіталей
    print(f'\nОрбітальні енергії ({method_name}):')

    if mol.spin == 0:
        # RHF
        print('\nЗаповнені орбіталі:')
        n_occ = mol.nelec[0]
        for i in range(n_occ):
            print(f'  MO {i+1:2d}: {mf.mo_energy[i]:10.6f} Ha '
                  f'({mf.mo_energy[i]*27.211386:8.4f} eV)')

        print('\nВіртуальні орбіталі (перші 5):')
        for i in range(n_occ, min(n_occ+5, len(mf.mo_energy))):
            print(f'  MO {i+1:2d}: {mf.mo_energy[i]:10.6f} Ha '
                  f'({mf.mo_energy[i]*27.211386:8.4f} eV)')
    else:
        # UHF
        print('\nАльфа-орбіталі (заповнені):')
        n_alpha = mol.nelec[0]
        for i in range(n_alpha):
            print(f'  α-MO {i+1:2d}: {mf.mo_energy[0][i]:10.6f} Ha '
                  f'({mf.mo_energy[0][i]*27.211386:8.4f} eV)')

        print('\nБета-орбіталі (заповнені):')
        n_beta = mol.nelec[1]
        for i in range(n_beta):
            print(f'  β-MO {i+1:2d}: {mf.mo_energy[1][i]:10.6f} Ha '
                  f'({mf.mo_energy[1][i]*27.211386:8.4f} eV)')

    # Заселеності Малікена
    print(f'\n{"="*60}')
    print('АНАЛІЗ ЗАСЕЛЕНОСТЕЙ (Mulliken)')
    print(f'{"="*60}')

    pop = mf.mulliken_pop()

    # Дипольний момент (для нейтральних атомів = 0)
    dip = mf.dip_moment(unit='Debye')
    print(f'\nДипольний момент: ({dip[0]:.4f}, {dip[1]:.4f}, '
          f'{dip[2]:.4f}) Debye')
    print(f'|μ| = {np.linalg.norm(dip):.6f} Debye')

    # Спінова густина (для відкритих систем)
    if mol.spin > 0:
        print(f'\nСпінова густина:')
        s = mf.spin_square()
        print(f'  <S²> = {s[0]:.4f}')
        print(f'  <S²> (очікуване) = {mol.spin*(mol.spin+2)/4:.4f}')
        print(f'  Забруднення спіном: {s[0] - mol.spin*(mol.spin+2)/4:.4f}')

    return mf, energy


# Приклади використання
if __name__ == '__main__':
    # Атом Li (основний стан)
    mf_li, e_li = analyze_atom('Li', spin=1, basis='cc-pvdz')

    # Атом C (триплет)
    mf_c, e_c = analyze_atom('C', spin=2, basis='6-31g*')

    # Катіон O+
    mf_o_plus, e_o_plus = analyze_atom('O', charge=1, spin=3,
                                        basis='aug-cc-pvdz')
\end{minted}

%% ========================================================
\section{Корисні функції та методи}
%% ========================================================

%% --------------------------------------------------------
\subsection{Інформація про атом}
%% --------------------------------------------------------

\begin{minted}{python}
from pyscf import gto
from pyscf.data import elements

mol = gto.M(atom='Zn 0 0 0', basis='def2-svp')

# Основні атомні характеристики
symbol = mol.atom_symbol(0)
charge = mol.atom_charge(0)
z = gto.charge(symbol)

print(f'Атом: {symbol}')
print(f'Атомний номер: {z}')
print(f'Заряд ядра: {charge}')
print(f'Атомна маса: {elements.MASSES[charge]:.4f} а.о.м.')
print(f'Ковалентний радіус: {elements.COV_RADII[charge]:.2f} Å')

# Кількість електронів (нейтральний атом: ne = Z)
nelectron = z - mol.charge
print(f'Електронів: {nelectron}')
\end{minted}

%% --------------------------------------------------------
\subsection{Маніпуляції з базисом}
%% --------------------------------------------------------

\begin{minted}{python}
import numpy as np
from pyscf import gto

mol = gto.M(atom='Si 0 0 0', basis='6-31g*')

# Отримання базисних функцій
print('Базисні функції (AO labels):')
for i, label in enumerate(mol.ao_labels(fmt=False)):
    atom_id, atom_symbol, shell_type, *rest = label
    print(f'{i:3d}: Атом {atom_symbol}, тип {shell_type}')

# Кількість функцій кожного типу
from collections import Counter
ao_types = [label[2] for label in mol.ao_labels(fmt=False)]
count = Counter(ao_types)

print(f'\nРозподіл по типах:')
for shell_type, num in sorted(count.items()):
    print(f'  {shell_type}: {num} функцій')

# Перекривання базисних функцій
s = mol.intor('int1e_ovlp')
print(f'\nМатриця перекривання: {s.shape}')
print(f'Діагональні елементи (норми): {np.diag(s)[:5]}')

# Загальна кількість AO
print(f'\nЗагальна кількість AO: {mol.nao_nr()}')
\end{minted}

%% --------------------------------------------------------
\subsection{Енергетичні компоненти}
%% --------------------------------------------------------

\begin{minted}{python}
from pyscf import gto, scf

mol = gto.M(atom='Ne 0 0 0', basis='cc-pvtz', symmetry=True)
mf = scf.RHF(mol)
energy = mf.kernel()

# Детальні компоненти енергії
print('Енергетичні компоненти:')
print(f'  Електрон-ядерна: {mf.energy_nuc():.8f} Ha')

# Енергетичні вкладення через методи mf
e_elec, e_coul_xc = mf.energy_elec()
print(f'  Електронна (E_elec): {e_elec:.8f} Ha')
print(f'  Кулон+обмін/кореляція: {e_coul_xc:.8f} Ha')  # для DFT це Coulomb+XC

print(f'  Повна енергія: {energy:.8f} Ha')

# Матриці Фока та густини
h1e = mf.get_hcore()      # Одноелектронний гамільтоніан
dm = mf.make_rdm1()       # Матриця густини
vhf = mf.get_veff()       # Хартрі–Фок / ефективний потенціал

print(f'\nРозміри матриць:')
print(f'  h1e: {h1e.shape}')
print(f'  dm: {dm.shape}')
print(f'  vhf: {vhf.shape}')

# Орбітальні енергії
mo_energy = mf.mo_energy
print(f'\nЕнергії МО (перші 5): {mo_energy[:5]}')
\end{minted}

%% --------------------------------------------------------
\subsection{Резюме}
%% --------------------------------------------------------

\begin{itemize}
    \item \textbf{Клас Mole} --- центральний об'єкт, що містить всю інформацію про систему.
    \item \textbf{Базисні набори} --- від мінімальних (STO-3G) до великих (cc-pVQZ); вибір залежить від задачі та компромісу точність/вартість.
    \item \textbf{Симетрія} --- прискорює розрахунки, але може обмежувати гнучкість при спонтанному руйнуванні симетрії.
    \item \textbf{Спін} --- критичний параметр для правильного опису основного стану відкрито-оболонкових систем.
    \item \textbf{Конвергенція} --- використовуйте DIIS, level-shift, Newton-Raphson або fractional occupation для стабілізації важких випадків.
\end{itemize}

%% --------------------------------------------------------
\subsection{Контрольні запитання}
%% --------------------------------------------------------

\begin{enumerate}
    \item Яка різниця між методами створення об'єкта Mole через \texttt{gto.M()} та покроково?
    \item Чому для атома Карбону у основному стані використовується \texttt{spin=2}?
    \item Коли слід використовувати дифузні функції (aug- базиси)?
    \item Що означає параметр \texttt{conv\_tol} і як він впливає на точність?
    \item Які методи початкового наближення найкраще підходять для атомів?
\end{enumerate}


%% --------------------------------------------------------
\subsection{Завдання для самостійної роботи}
%% --------------------------------------------------------

\begin{enumerate}
    \item Створіть функцію, яка автоматично визначає правильний спін для атомів першого та другого періодів.
    \item Порівняйте енергії атома Неону з різними базисними наборами (STO-3G, 6-31G, cc-pVDZ, cc-pVTZ) та побудуйте графік залежності енергії від розміру базису.
    \item Дослідіть вплив симетрії на швидкість розрахунку для атома Аргону: порівняйте час виконання з \texttt{symmetry=True} та \texttt{symmetry=False}.
    \item Обчисліть енергію іонізації атома Літію як різницю енергій Li та Li$^+$.
    \item Для атома Заліза (Fe) з різними спіновими станами (2S = 2, 4, 6) знайдіть, який стан має найнижчу енергію.
\end{enumerate}

У наступному розділі ми детально розглянемо метод Хартрі-Фока та його застосування до розрахунків атомів.