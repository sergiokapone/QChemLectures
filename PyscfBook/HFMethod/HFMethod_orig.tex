% !TeX program = lualatex
% !TeX encoding = utf8
% !TeX spellcheck = uk_UA
% !TeX root =../PyscfBook.tex

%=========================================================
\Opensolutionfile{answer}[\currfilebase/\currfilebase-Answers]
\chapter{Метод Хартрі-Фока для атомів}\label{\currfilebase}
%=========================================================

%% --------------------------------------------------------
\section{Теоретичні основи методу Хартрі-Фока}
%% --------------------------------------------------------

%% --------------------------------------------------------
\subsection{Рівняння Хартрі-Фока}
%% --------------------------------------------------------

Метод Хартрі-Фока (HF) є наближеним методом розв'язання рівняння Шредінгера для багатоелектронних систем. Основна ідея полягає у представленні багатоелектронної хвильової функції у вигляді єдиного детермінанта Слейтера:

\begin{equation}
\Psi(\mathbf{r}_1, \mathbf{r}_2, \ldots, \mathbf{r}_N) = \frac{1}{\sqrt{N!}}
\begin{vmatrix}
\psi_1(\mathbf{r}_1) & \psi_2(\mathbf{r}_1) & \cdots & \psi_N(\mathbf{r}_1) \\
\psi_1(\mathbf{r}_2) & \psi_2(\mathbf{r}_2) & \cdots & \psi_N(\mathbf{r}_2) \\
\vdots & \vdots & \ddots & \vdots \\
\psi_1(\mathbf{r}_N) & \psi_2(\mathbf{r}_N) & \cdots & \psi_N(\mathbf{r}_N)
\end{vmatrix}
\end{equation}

де $\psi_i(\mathbf{r})$ --- спін-орбіталі, які є добутком просторової частини та спінової функції.

Канонічні рівняння Хартрі-Фока мають вигляд:

\begin{equation}
\hat{f} \psi_i = \varepsilon_i \psi_i
\end{equation}

де $\hat{f}$ --- оператор Фока:

\begin{equation}
\hat{f} = \hat{h} + \sum_{j=1}^{N} (\hat{J}_j - \hat{K}_j)
\end{equation}

Тут $\hat{h}$ --- одноелектронний оператор (кінетична енергія + притягання до ядра), $\hat{J}_j$ --- кулонівський оператор, $\hat{K}_j$ --- обмінний оператор.

%% --------------------------------------------------------
\subsection{Варіанти методу Хартрі-Фока}
%% --------------------------------------------------------

%% --------------------------------------------------------
\subsubsection{Restricted Hartree-Fock (RHF)}
%% --------------------------------------------------------

RHF використовується для систем з замкненими оболонками, де всі електрони спарені:

\begin{equation}
\psi_i^\alpha(\mathbf{r}) = \psi_i^\beta(\mathbf{r}) = \phi_i(\mathbf{r})
\end{equation}

Підходить для: He, Be, Ne, Mg, Ar, Ca, Zn (у синглетних станах).

%% --------------------------------------------------------
\subsubsection{Unrestricted Hartree-Fock (UHF)}
%% --------------------------------------------------------

UHF дозволяє різні просторові орбіталі для альфа та бета спінів:

\begin{equation}
\psi_i^\alpha(\mathbf{r}) \neq \psi_i^\beta(\mathbf{r})
\end{equation}

Підходить для: всіх відкритих систем (H, Li, B, C, N, O, F та їх іони).


\subsubsection{Restricted Open-shell Hartree-Fock (ROHF)}

ROHF --- компроміс між RHF та UHF. Спарені електрони описуються однаковими орбіталями, неспарені --- різними:

\begin{equation}
\begin{cases}
\psi_i^\alpha = \psi_i^\beta & \text{для спарених} \\
\psi_i^\alpha \neq \psi_i^\beta & \text{для неспарених}
\end{cases}
\end{equation}

%% --------------------------------------------------------
\subsection{Енергія Хартрі-Фока}
%% --------------------------------------------------------

Повна енергія системи у методі HF:

\begin{equation}
E_{HF} = \sum_{i=1}^{N} h_{ii} + \frac{1}{2} \sum_{i,j}^{N} (J_{ij} - K_{ij}) + V_{NN}
\end{equation}

де:
\begin{itemize}
    \item $h_{ii}$ --- одноелектронні інтеграли
    \item $J_{ij}$ --- кулонівські інтеграли
    \item $K_{ij}$ --- обмінні інтеграли
    \item $V_{NN}$ --- енергія міжядерного відштовхування (= 0 для атомів)
\end{itemize}


%% --------------------------------------------------------
\section{Розрахунок атома Гідрогену}
%% --------------------------------------------------------

Атом Гідрогену є найпростішим квантовим об'єктом, який можна описати в рамках не лише хімії, а й фундаментальної квантової механіки. Його Гамільтоніан має вигляд:
\[
\hat{H} = -\frac{1}{2}\nabla^2 - \frac{1}{r},
\]
де \(-\frac{1}{2}\nabla^2\) --- оператор кінетичної енергії електрона, а \(-\frac{1}{r}\) --- потенціал кулонівської взаємодії між електроном і ядром.
Ця система має аналітичне рішення, і енергія основного стану дорівнює
\[
E_1 = -\frac{1}{2}\ \text{Ha}.
\]
Для атома Гідрогену це рішення можна отримати навіть чисельно в PySCF, що дозволяє перевірити точність обраного базисного набору та методів квантово-хімічних розрахунків.

%% --------------------------------------------------------
\subsection{Особливості одноелектронної системи}
%% --------------------------------------------------------

Атом Гідрогену є одноелектронною системою, тому метод Гартрі–Фока (HF) не містить жодних апроксимацій, окрім обмежень базисного набору.
У звичайних багатoелектронних атомах HF наближає взаємодію електронів середнім потенціалом, але для H відсутнє електрон–електронне відштовхування, тож метод дає \emph{точну} хвильову функцію для обраного базису.

\begin{minted}{python}
from pyscf import gto, scf
import numpy as np

# Створення атома Гідрогену
mol = gto.M(
    atom='H 0 0 0',   # координати ядра
    basis='sto-3g',   # мінімальний базис
    spin=1,           # один неспарений електрон
    verbose=4         # рівень деталізації виводу
)

print(f'Кількість електронів: {mol.nelectron}')
print(f'Базисних функцій: {mol.nao_nr()}')

# Розрахунок методом UHF (необмежений Гартрі-Фок)
mf = scf.UHF(mol)
energy = mf.kernel()

print(f'\nЕнергія H (STO-3G): {energy:.8f} Ha')
print(f'Енергія H (STO-3G): {energy * 27.211386:.6f} eV')

# Теоретичне значення
print(f'Теоретична енергія: -0.5 Ha')
print(f'Похибка базису: {abs(energy + 0.5):.6f} Ha')
\end{minted}

Отримане значення енергії наближається до \(-0.5\) Ha, але точність залежить від базису. STO-3G --- це мінімальний базис, де кожна орбіталь апроксимується трьома гаусовими функціями, тому результат має невелику похибку (близько \(10^{-3}\) Ha).

%% --------------------------------------------------------
\subsection{Залежність від базисного набору}
%% --------------------------------------------------------

Базисний набір визначає якість апроксимації хвильової функції.
Чим більший набір, тим ближче розрахована енергія до аналітичного результату.
Для атома Гідрогену ця збіжність особливо показова, бо ми можемо порівняти з точним розв’язком.

У коді нижче порівнюються кілька популярних базисів, від найменшого STO-3G до розширених кореляційно-узгоджених наборів cc-pV5Z. Для кожного базису обчислюється енергія та похибка відносно \(-0.5\) Ha.

\begin{minted}{python}
from pyscf import gto, scf
import matplotlib.pyplot as plt

basis_sets = ['sto-3g', '3-21g', '6-31g', '6-311g',
              'cc-pvdz', 'cc-pvtz', 'cc-pvqz', 'cc-pv5z']

energies = []
n_basis = []

print('Базис           N_bas    Енергія (Ha)    Похибка (mHa)')
print('-' * 60)

for basis in basis_sets:
    try:
        mol = gto.M(atom='H 0 0 0', basis=basis, spin=1, verbose=0)
        mf = scf.UHF(mol)
        e = mf.kernel()

        n = mol.nao_nr()
        error = (e + 0.5) * 1000  # похибка в міліГартрі

        energies.append(e)
        n_basis.append(n)

        print(f'{basis:15s} {n:3d}    {e:12.8f}    {error:8.4f}')
    except:
        print(f'{basis:15s} --- недоступний')

# Побудова графіка збіжності
plt.figure(figsize=(10, 6))
plt.plot(n_basis, energies, 'o-', linewidth=2, markersize=8)
plt.axhline(y=-0.5, color='r', linestyle='--', label='Точне значення')
plt.xlabel('Кількість базисних функцій', fontsize=12)
plt.ylabel('Енергія (Ha)', fontsize=12)
plt.title('Збіжність енергії атома H від базисного набору', fontsize=14)
plt.grid(True, alpha=0.3)
plt.legend()
plt.tight_layout()
plt.savefig('h_atom_basis_convergence.pdf')
plt.show()
\end{minted}

З графіка видно, що зі збільшенням кількості базисних функцій енергія швидко наближається до точного значення \(-0.5\) Ha.
Набори типу \texttt{cc-pVQZ} або \texttt{cc-pV5Z} практично дають збіжність до повного базисного ліміту (CBS limit).

%% --------------------------------------------------------
\subsection{Аналіз орбіталей}
%% --------------------------------------------------------

Хоча в атома Гідрогену існує лише одна заповнена орбіталь (1s), PySCF дозволяє вивести енергетичні рівні для всіх функцій базису, а також дослідити матрицю густини.
Цей підхід зручний для демонстрації структури HF-розрахунку.

\begin{minted}{python}
from pyscf import gto, scf
import numpy as np

mol = gto.M(atom='H 0 0 0', basis='cc-pvtz', spin=1)
mf = scf.UHF(mol)
energy = mf.kernel()

# Орбітальні енергії
print('\nОрбітальні енергії (альфа-спін):')
print('-' * 50)
for i, (e, label) in enumerate(zip(mf.mo_energy[0], mol.ao_labels())):
    occ = '(occ)' if i < mol.nelec[0] else '(virt)'
    print(f'{i+1:2d}. {label:20s}: {e:10.6f} Ha {occ}')

print(f'\nЕнергія 1s орбіталі: {mf.mo_energy[0][0]:.8f} Ha')
print(f'Теоретична енергія:  -0.50000000 Ha')

# Матриця густини
dm = mf.make_rdm1()
print(f'\nМатриця густини (альфа): {dm[0].shape}')
print(f'След dm: {np.trace(dm[0]):.1f} (має дорівнювати 1)')
\end{minted}

Матриця густини (\texttt{dm}) відображає заповнення орбіталей. Її слід дорівнює кількості електронів (тут --- 1).
Такі розрахунки є основою для подальшого аналізу електронної густини, побудови орбіталей і візуалізації електронної хмари.

%% --------------------------------------------------------
\subsection{Висновки}
%% --------------------------------------------------------

\begin{itemize}
    \item Для атома Гідрогену метод Гартрі–Фока є \textbf{точним}, бо немає взаємодії між електронами.
    \item Основна похибка виникає через обмеження базисного набору.
    \item Зі збільшенням кількості базисних функцій енергія швидко збігається до точного значення \(-0.5\) Ha.
    \item PySCF дозволяє досліджувати вплив базису, аналізувати орбіталі, матриці густини та підготовлює ґрунт для подальшого розгляду багатoелектронних систем.
\end{itemize}


%% ========================================================
\section{Розрахунок атома Гелію}
%% ========================================================

%% --------------------------------------------------------
\subsection{Двоелектронна система}
%% --------------------------------------------------------

Атом гелію є фундаментальним прикладом для демонстрації методів \textbf{Хартрі–Фока (HF)}.
Це перша система, де проявляється \textbf{електрон–електронна кореляція}, відсутня в атомі водню.

Два електрони гелію мають протилежні спіни й заповнюють одну й ту саму орбіталь $1s$, тому це \emph{замкнена оболонка}
зі спіном $S = 0$ (синглет, $M = 1$).

\begin{minted}{python}
from pyscf import gto, scf

# Атом He (основний стан ¹S)
mol = gto.M(
    atom='He 0 0 0',
    basis='cc-pvtz',
    spin=0,  # Замкнена оболонка
    verbose=4
)

print(f'Електронна конфігурація: 1s²')
print(f'Кількість електронів: {mol.nelectron}')

# RHF для замкненої оболонки
mf = scf.RHF(mol)
energy = mf.kernel()

print(f'\nЕнергія He (HF): {energy:.8f} Ha')
print(f'Енергія He (HF): {energy * 27.211386:.6f} eV')

# Експериментальна енергія He: -2.90372 Ha
exp_energy = -2.90372
correlation_energy = exp_energy - energy

print(f'\nЕкспериментальна енергія: {exp_energy:.6f} Ha')
print(f'Кореляційна енергія: {correlation_energy:.6f} Ha')
print(f'Відносна похибка HF: {abs(correlation_energy/exp_energy)*100:.2f}%')
\end{minted}

\textbf{Коментар.}
Метод RHF нехтує кореляцією між електронами, тобто вважає, що хвильова функція є добутком одноелектронних орбіталей.
Тому енергія HF завжди \emph{вище} (менш від’ємна), ніж точна. Для гелію похибка складає близько \(\sim 1.7\%\).
Ця різниця --- це \textbf{кореляційна енергія}:
\[
E_{\text{corr}} = E_{\text{exact}} - E_{\text{HF}}
\]


%% --------------------------------------------------------
\subsection{Порівняння RHF та UHF}
%% --------------------------------------------------------

Оскільки гелій має замкнену оболонку ($N_\alpha = N_\beta$), обидва методи --- \textbf{RHF} (restricted HF)
і \textbf{UHF} (unrestricted HF) --- дають ідентичні результати.
UHF дозволяє $\alpha$ та $\beta$ орбіталям відрізнятися, але тут ця свобода не використовується.

\begin{minted}{python}
from pyscf import gto, scf

mol = gto.M(atom='He 0 0 0', basis='6-31g', spin=0)

# RHF розрахунок
mf_rhf = scf.RHF(mol)
mf_rhf.verbose = 0
e_rhf = mf_rhf.kernel()

# UHF розрахунок
mf_uhf = scf.UHF(mol)
mf_uhf.verbose = 0
e_uhf = mf_uhf.kernel()

print(f'RHF енергія: {e_rhf:.10f} Ha')
print(f'UHF енергія: {e_uhf:.10f} Ha')
print(f'Різниця: {abs(e_rhf - e_uhf):.2e} Ha')

# Перевірка симетрії спіну
s2_uhf = mf_uhf.spin_square()
print(f'\n<S²> (UHF): {s2_uhf[0]:.6f}')
print(f'<S²> (точно): 0.000000')
\end{minted}

\textbf{Коментар.}
UHF може порушувати спінову симетрію (\textit{spin conta\-mination}), особливо для відкрито-оболонкових систем.
Тут же $S^2 = 0$, тобто спінова симетрія зберігається, і RHF ≡ UHF.


%% --------------------------------------------------------
\subsection{Збуджені стани Гелію}
%% --------------------------------------------------------

У збуджених станах один електрон переходить на більш високий рівень (наприклад, $2s$),
а система може існувати в двох спінових конфігураціях:

\begin{itemize}
    \item \textbf{Синглет:} $S=0$ --- антисиметрична за спіном, симетрична за просторовою координатою.
    \item \textbf{Триплет:} $S=1$ --- симетрична за спіном, антисиметрична за просторовою частиною.
\end{itemize}

У PySCF ці стани можна моделювати за допомогою відповідного значення параметра \texttt{spin}
та методу \texttt{ROHF} для частково заповнених оболонок.

\begin{minted}{python}
from pyscf import gto, scf

def he_excited_state(config='1s2s', spin=0, basis='cc-pvdz'):
    """
    Розрахунок збуджених станів He

    config: '1s2s' (синглет або триплет)
    spin: 0 для синглету, 2 для триплету
    """
    mol = gto.M(atom='He 0 0 0', basis=basis, spin=spin)

    if spin == 0:
        # Синглет: 1s² → 1s2s ¹S
        mf = scf.RHF(mol)
    else:
        # Триплет: 1s² → 1s2s ³S
        mf = scf.ROHF(mol)

    # Для збуджених станів можна використати MOM (maximum overlap method)
    mf = scf.addons.mom_occ(mf, mf.make_rdm1(), mf.get_occ())
    mf.verbose = 0
    energy = mf.kernel()

    return energy

# Основний стан
mol_gs = gto.M(atom='He 0 0 0', basis='cc-pvdz', spin=0)
mf_gs = scf.RHF(mol_gs)
mf_gs.verbose = 0
e_gs = mf_gs.kernel()

print('Стани атома Гелію (cc-pVDZ):')
print('-' * 50)
print(f'1s² (¹S, основний): {e_gs:.6f} Ha')
print(f'  = {e_gs * 27.211386:.2f} eV')

# Примітка: для збуджених станів
# краще використовувати методи типу TD-DFT або CASSCF
\end{minted}

\textbf{Коментар.}
Метод \texttt{MOM (Maximum Overlap Method)} дозволяє стабілізувати SCF для збуджених станів,
зберігаючи певну орбітальну конфігурацію. Проте результати залишаються наближеними.
Для точного опису необхідно застосовувати багатоконфігураційні підходи (наприклад, CASSCF, CI, TD-DFT).


\textbf{Підсумок:}
\begin{itemize}
    \item Гелій --- базовий тест для валідації HF-методу.
    \item Різниця між RHF і експериментом демонструє значення кореляційної енергії.
    \item Збуджені стани потребують спеціальних методів (MOM, CASSCF, TD-DFT).
\end{itemize}


%% --------------------------------------------------------
\section{Атоми другого періоду (Li--Ne)}
%% --------------------------------------------------------

%% --------------------------------------------------------
\subsection{Літій (Li, Z=3)}
%% --------------------------------------------------------

Атом Літію --- перший багатoелектронний атом, у якому проявляється \textbf{неспарений електрон} та \textbf{спінова поляризація}.
Електронна конфігурація:
\[
\text{Li: } 1s^2 2s^1.
\]
Два перші електрони утворюють замкнену оболонку (1s), а третій --- одинокий у підоболонці \(2s\), що зумовлює мультиплетність \(2S\) (спін \(S = \frac{1}{2}\)).

Через наявність неспареного електрона метод \textbf{UHF} (Unrestricted Hartree–Fock) є природним вибором.
UHF дозволяє альфа- та бета-орбіталям відрізнятися, тобто хвильова функція не змушена мати однакову просторову форму для різних спінів.

\begin{minted}{python}
from pyscf import gto, scf

# Li: [He] 2s¹, основний стан ²S
mol = gto.M(
    atom='Li 0 0 0',
    basis='cc-pvdz',
    spin=1,   # один неспарений електрон (S=1/2)
    symmetry=True
)

print('Літій (Li):')
print(f'  Конфігурація: [He] 2s¹')
print(f'  Основний стан: ²S')
print(f'  Електронів: {mol.nelectron}')

# UHF розрахунок
mf = scf.UHF(mol)
energy = mf.kernel()

print(f'\nЕнергія Li: {energy:.8f} Ha')
print(f'Енергія Li: {energy * 27.211386:.4f} eV')

# Аналіз заселеностей
print('\nЗаселеності Малікена:')
pop = mf.mulliken_pop()

# Орбітальний аналіз
print('\nАльфа-орбіталі (заповнені):')
for i in range(mol.nelec[0]):
    print(f'  α-MO {i+1}: {mf.mo_energy[0][i]:10.6f} Ha')

print('\nБета-орбіталі (заповнені):')
for i in range(mol.nelec[1]):
    print(f'  β-MO {i+1}: {mf.mo_energy[1][i]:10.6f} Ha')

# Спінова густина
s2 = mf.spin_square()
print(f'\n<S²> = {s2[0]:.6f} (очікується 0.75)')
\end{minted}

\paragraph{Коментарі.}
\begin{itemize}
  \item Значення \(\langle S^2 \rangle \approx 0.75\) свідчить про правильний спіновий стан подвійності (мультиплетність \(2S+1=2\)).
  \item Наявність різниці між енергіями альфа- та бета-орбіталей демонструє спінову асиметрію.
  \item Метод UHF може частково порушувати симетрію (так звана \textit{spin contamination}), але для Li це незначно.
\end{itemize}

Енергія, отримана методом HF, для Li становить близько \(-7.432\) Ha у базисі cc-pVDZ, тоді як експериментальна енергія основного стану (повна) --- близько \(-7.478\) Ha.
Таким чином, кореляційна похибка становить близько \(0.046\) Ha (приблизно 1.25 eV).

Цей приклад є першим, де проявляється \emph{кореляція електронів}, яку HF не враховує. В подальших розділах буде показано, як методи MP2, CI та CC враховують ці ефекти.

%% --------------------------------------------------------
\subsection{Берилій (Be, Z=4)}
%% --------------------------------------------------------

Атом Берилію має електронну конфігурацію
\[
\text{Be: } 1s^2 2s^2.
\]
Тут усі орбіталі парні, тому спінова поляризація відсутня, і зручно використовувати \textbf{RHF} (Restricted Hartree–Fock).
Обидва електрони у підоболонці \(2s\) мають протилежні спіни, тож система має мультиплетність \(1S\) (синглетний стан).

\begin{minted}{python}
from pyscf import gto, scf

# Be: [He] 2s², основний стан ¹S
mol = gto.M(
    atom='Be 0 0 0',
    basis='cc-pvtz',
    spin=0,        # замкнена оболонка
    symmetry=True
)

print('Берилій (Be):')
print(f'  Конфігурація: [He] 2s²')
print(f'  Основний стан: ¹S')

# RHF розрахунок
mf = scf.RHF(mol)
energy = mf.kernel()

print(f'\nЕнергія Be: {energy:.8f} Ha')

# Порівняння з експериментом
exp_be = -14.6674  # Ha (експериментальна повна енергія)
print(f'Експериментальна: {exp_be:.4f} Ha')
print(f'Кореляційна енергія: {exp_be - energy:.4f} Ha')
\end{minted}

\paragraph{Обговорення.}
\begin{itemize}
  \item Для Be HF-енергія виходить приблизно \(-14.573\) Ha (у базисі cc-pVTZ), тоді як експериментальна --- \(-14.667\) Ha.
  \item Різниця близько \(0.094\) Ha (\(\approx 2.6\) eV) --- це \textbf{кореляційна енергія}, тобто внесок взаємодії електронів, не врахований у HF.
  \item У Берилія ефекти електронної кореляції вже досить значні, адже електрони в орбіталі \(2s\) взаємодіють один з одним.
  \item Цей випадок є гарною ілюстрацією межі застосування методу Гартрі–Фока.
\end{itemize}

\paragraph{Висновки для атомів Li і Be.}
\begin{itemize}
  \item Li демонструє появу неспареного електрона і спінової поляризації (UHF необхідний).
  \item Be --- перший приклад, де \textbf{електронна кореляція} дає помітну похибку енергії.
  \item PySCF дозволяє наочно дослідити вплив базису, спіну, симетрії та методів на точність енергії.
\end{itemize}


%% --------------------------------------------------------
\subsection{Бор--Неон: систематичне дослідження}
%% --------------------------------------------------------

Після розгляду окремих атомів Літію та Берилію доцільно перейти до систематичного аналізу всіх атомів другого періоду (від Бору до Неону).
У цих атомах поступово заповнюється \(2p\)-підрівень, і змінюється як спінова мультиплетність, так і форма електронної густини.
Метод Гартрі–Фока дозволяє побачити, як змінюється енергія системи при збільшенні числа електронів, а також як проявляється спінова поляризація у відкритих оболонках.

\paragraph{Електронні конфігурації.}
\[
\begin{array}{llcl}
\text{Li:} & [\text{He}]\,2s^1 & \quad & {}^2S \\
\text{Be:} & [\text{He}]\,2s^2 & & {}^1S \\
\text{B:}  & [\text{He}]\,2s^2 2p^1 & & {}^2P \\
\text{C:}  & [\text{He}]\,2s^2 2p^2 & & {}^3P \\
\text{N:}  & [\text{He}]\,2s^2 2p^3 & & {}^4S \\
\text{O:}  & [\text{He}]\,2s^2 2p^4 & & {}^3P \\
\text{F:}  & [\text{He}]\,2s^2 2p^5 & & {}^2P \\
\text{Ne:} & [\text{He}]\,2s^2 2p^6 & & {}^1S
\end{array}
\]
Як видно, кількість неспарених електронів збільшується від Бору до Нітрогену, а потім зменшується до Неону, що зумовлює зміну спінового стану та мультиплетності.

\paragraph{Мета дослідження.}
Провести розрахунок енергій Гартрі–Фока для атомів другого періоду в однаковому базисі \texttt{cc-pVDZ}, оцінити правильність спінового стану (через \(\langle S^2 \rangle\)) та проаналізувати систематичні тенденції.

\begin{minted}{python}
from pyscf import gto, scf
import numpy as np

# Дані про атоми другого періоду
atoms_data = [
    ('Li', 1, '²S', '[He] 2s¹'),
    ('Be', 0, '¹S', '[He] 2s²'),
    ('B',  1, '²P', '[He] 2s² 2p¹'),
    ('C',  2, '³P', '[He] 2s² 2p²'),
    ('N',  3, '⁴S', '[He] 2s² 2p³'),
    ('O',  2, '³P', '[He] 2s² 2p⁴'),
    ('F',  1, '²P', '[He] 2s² 2p⁵'),
    ('Ne', 0, '¹S', '[He] 2s² 2p⁶')
]

basis = 'cc-pvdz'
print(f'Розрахунок атомів 2-го періоду (базис: {basis})')
print('=' * 70)
print(f'{"Атом":4s} {"Спін":4s} {"Терм":4s} {"E(HF), Ha":15s} '
      f'{"E(HF), eV":12s}')
print('-' * 70)

energies = {}

for symbol, spin, term, config in atoms_data:
    mol = gto.M(
        atom=f'{symbol} 0 0 0',
        basis=basis,
        spin=spin,
        symmetry=True,
        verbose=0
    )

    # Вибір методу SCF
    if spin == 0:
        mf = scf.RHF(mol)
    else:
        mf = scf.UHF(mol)

    mf.verbose = 0
    mf.conv_tol = 1e-10
    energy = mf.kernel()
    energies[symbol] = energy

    e_ev = energy * 27.211386
    print(f'{symbol:4s} {spin:4d} {term:4s} {energy:15.8f} {e_ev:12.2f}')

    # Додаткова інформація для відкритих оболонок
    if spin > 0:
        s2 = mf.spin_square()
        expected_s2 = spin * (spin + 2) / 4
        print(f'     <S²> = {s2[0]:.4f} (очікується {expected_s2:.4f})')

print('=' * 70)

# Збереження результатів
np.savez('second_period_hf.npz', **energies)
\end{minted}

\paragraph{Коментарі до коду.}
\begin{itemize}
  \item Для кожного атома автоматично обирається тип SCF: \texttt{RHF} (для замкнених оболонок, $S=0$) або \texttt{UHF} (для відкритих).
  \item Параметр \texttt{spin} у PySCF означає різницю між кількістю альфа- та бета-електронів:
        \(\text{spin} = N_\alpha - N_\beta = 2S.\)
  \item Розрахунок \(\langle S^2 \rangle\) дозволяє перевірити правильність спінового стану. Для ідеального випадку значення має збігатися з теоретичним \(S(S+1)\).
  \item У файлі \texttt{second\_period\_hf.npz} зберігаються всі енергії для подальшого аналізу або побудови графіків.
\end{itemize}

\paragraph{Очікувані тенденції.}
\begin{enumerate}
  \item Повна енергія атома зменшується (стає більш негативною) із зростанням атомного номера $Z$.
  \item Енергія спостерігає стрибки на межі заповнення оболонок: при переходах Be→B, N→O, F→Ne.
  \item Спінова мультиплетність відображає заповнення $2p$-орбіталей згідно з \textbf{правилом Гунда} --- максимальний спін у середині підоболонки (для N).
  \item Значення \(\langle S^2 \rangle\) для UHF повинні бути близькі до теоретичних, але можуть мати невеликі відхилення через \textit{spin contamination}.
\end{enumerate}

\paragraph{Фізичне узагальнення.}
Цей розрахунок демонструє фундаментальну властивість методу Гартрі–Фока:
він добре описує загальну структуру енергетичних рівнів і тенденції в періодичній таблиці, але не враховує електронну кореляцію, через що абсолютні значення енергії мають систематичну похибку.

\paragraph{Подальші кроки.}
Наступним логічним етапом є додавання пост-Гартрі–Фок методів (MP2, CI, CCSD), щоб показати, як кореляція електронів уточнює енергії і дозволяє досягати експериментальної точності.


%% --------------------------------------------------------
\subsection{Енергії іонізації}
%% --------------------------------------------------------

Іонізаційна енергія є однією з фундаментальних характеристик атома, що описує енерговитрати на видалення одного електрона.
У квантово-хімічних розрахунках її визначають як різницю повних енергій катіона \(E(A^+)\) і нейтрального атома \(E(A)\):
\[
I = E(A^+) - E(A)
\]
де енергії \(E\) обчислюються в межах методу Гартрі–Фока або його узагальнень.
Для ізольованих атомів другого періоду така процедура дозволяє отримати якісно правильну послідовність енергій іонізації, навіть попри те, що метод HF систематично недооцінює абсолютні значення через відсутність кореляційних ефектів.


\begin{minted}{python}
from pyscf import gto, scf

def ionization_energy(symbol, charge_neutral=0, spin_neutral=None,
                     spin_cation=None, basis='cc-pvtz'):
    """
    Розрахунок енергії іонізації атома
    IE = E(A⁺) - E(A)
    """
    # Нейтральний атом
    mol_neutral = gto.M(
        atom=f'{symbol} 0 0 0',
        basis=basis,
        charge=charge_neutral,
        spin=spin_neutral,
        verbose=0
    )

    if spin_neutral == 0:
        mf_neutral = scf.RHF(mol_neutral)
    else:
        mf_neutral = scf.UHF(mol_neutral)

    mf_neutral.verbose = 0
    e_neutral = mf_neutral.kernel()

    # Катіон
    mol_cation = gto.M(
        atom=f'{symbol} 0 0 0',
        basis=basis,
        charge=charge_neutral + 1,
        spin=spin_cation,
        verbose=0
    )

    if spin_cation == 0:
        mf_cation = scf.RHF(mol_cation)
    else:
        mf_cation = scf.UHF(mol_cation)

    mf_cation.verbose = 0
    e_cation = mf_cation.kernel()

    # Енергія іонізації
    ie_ha = e_cation - e_neutral
    ie_ev = ie_ha * 27.211386

    return ie_ev, e_neutral, e_cation

# Розрахунок IE для атомів 2-го періоду
atoms_ie = [
    ('Li', 1, 0),  # Li → Li⁺
    ('Be', 0, 1),  # Be → Be⁺
    ('B',  1, 0),  # B → B⁺
    ('C',  2, 1),  # C → C⁺
    ('N',  3, 2),  # N → N⁺
    ('O',  2, 3),  # O → O⁺
    ('F',  1, 2),  # F → F⁺
    ('Ne', 0, 1),  # Ne → Ne⁺
]

# Експериментальні значення (eV)
exp_ie = {
    'Li': 5.39, 'Be': 9.32, 'B': 8.30, 'C': 11.26,
    'N': 14.53, 'O': 13.62, 'F': 17.42, 'Ne': 21.56
}

print('Енергії іонізації атомів 2-го періоду')
print('=' * 65)
print(f'{"Атом":4s} {"IE(HF), eV":12s} {"IE(exp), eV":12s} {"Похибка, eV":12s}')
print('-' * 65)

for symbol, spin_n, spin_c in atoms_ie:
    ie_calc, e_n, e_c = ionization_energy(symbol, 0, spin_n, spin_c)
    ie_experimental = exp_ie[symbol]
    error = ie_calc - ie_experimental

    print(f'{symbol:4s} {ie_calc:12.2f} {ie_experimental:12.2f} '
          f'{error:12.2f}')

print('=' * 65)
\end{minted}

Результатом буде таблиця іонізаційних енергій у електронвольтах.
Порівнюючи їх з експериментальними, можна оцінити якість базисного набору та межі методу Гартрі–Фока.
Для більш точних результатів використовують після-HF методи, наприклад MP2 або CCSD, які враховують електронну кореляцію.

%% --------------------------------------------------------
\section{Аналіз енергій та орбіталей}
%% --------------------------------------------------------


%% --------------------------------------------------------
\subsection{Енергетична діаграма орбіталей}
%% --------------------------------------------------------


Енергетичні діаграми орбіталей є наочним способом представлення енергетичного спектру молекулярних орбіталей (МО), що виникають у результаті розв’язання рівнянь Гартрі–Фока.


\begin{minted}{python}
from pyscf import gto, scf
import matplotlib.pyplot as plt
import numpy as np

def plot_orbital_diagram(symbol, spin, basis='cc-pvdz'):
    """Побудова діаграми орбітальних енергій"""

    mol = gto.M(
        atom=f'{symbol} 0 0 0',
        basis=basis,
        spin=spin,
        verbose=0
    )

    if spin == 0:
        mf = scf.RHF(mol)
    else:
        mf = scf.UHF(mol)

    mf.verbose = 0
    mf.kernel()

    fig, ax = plt.subplots(figsize=(8, 10))

    if spin == 0:
        # RHF: одна колонка орбіталей
        energies = mf.mo_energy * 27.211386  # eV
        n_occ = mol.nelec[0]

        for i, e in enumerate(energies[:n_occ+5]):
            color = 'blue' if i < n_occ else 'red'
            label = mol.ao_labels()[i] if i < len(mol.ao_labels()) else ''
            ax.hlines(e, 0.2, 0.8, colors=color, linewidth=2)
            ax.text(0.85, e, f'{label}', fontsize=10, va='center')

            # Стрілки для електронів
            if i < n_occ:
                ax.arrow(0.35, e+0.3, 0, -0.25, head_width=0.05,
                        head_length=0.1, fc='black', ec='black')
                ax.arrow(0.65, e-0.3, 0, 0.25, head_width=0.05,
                        head_length=0.1, fc='black', ec='black')
    else:
        # UHF: дві колонки (альфа та бета)
        e_alpha = mf.mo_energy[0] * 27.211386
        e_beta = mf.mo_energy[1] * 27.211386
        n_alpha, n_beta = mol.nelec

        # Альфа орбіталі
        for i, e in enumerate(e_alpha[:n_alpha+3]):
            color = 'blue' if i < n_alpha else 'red'
            ax.hlines(e, 0.1, 0.4, colors=color, linewidth=2)
            if i < n_alpha:
                ax.arrow(0.25, e+0.3, 0, -0.25, head_width=0.04,
                        head_length=0.1, fc='black', ec='black')

        # Бета орбіталі
        for i, e in enumerate(e_beta[:n_beta+3]):
            color = 'blue' if i < n_beta else 'red'
            ax.hlines(e, 0.6, 0.9, colors=color, linewidth=2)
            if i < n_beta:
                ax.arrow(0.75, e-0.3, 0, 0.25, head_width=0.04,
                        head_length=0.1, fc='black', ec='black')

        ax.text(0.25, min(e_alpha[:5])-2, 'α', fontsize=14, ha='center')
        ax.text(0.75, min(e_beta[:5])-2, 'β', fontsize=14, ha='center')

    ax.set_xlim(0, 1)
    ax.set_ylabel('Енергія (eV)', fontsize=12)
    ax.set_title(f'Діаграма орбіталей {symbol}', fontsize=14)
    ax.set_xticks([])
    ax.grid(True, alpha=0.3, axis='y')

    plt.tight_layout()
    plt.savefig(f'{symbol}_orbital_diagram.pdf')
    plt.show()

# Приклади
plot_orbital_diagram('C', spin=2)   # Вуглець
plot_orbital_diagram('Ne', spin=0)  # Неон
\end{minted}

%% --------------------------------------------------------
\subsection{Розподіл електронної густини}
%% --------------------------------------------------------

Розподіл електронної густини $\rho(\mathbf{r})$ є однією з ключових величин у квантовій хімії.
Саме ця функція визначає, де саме в просторі «перебувають» електрони атома або молекули, і, отже, пояснює більшість хімічних і спектроскопічних властивостей системи.

Згідно з однодетермінантним наближенням Гартрі–Фока, електронна густина визначається як
\[
\rho(\mathbf{r}) = \sum_{i}^{\text{occ}} |\psi_i(\mathbf{r})|^2,
\]
де $\psi_i(\mathbf{r})$ --- орбіталі, а сума береться по всіх зайнятих орбіталях.

У програмному пакеті \texttt{PySCF} густина може бути обчислена як на сітці, так і в окремих точках простору, що дозволяє візуалізувати просторовий розподіл електронів.

%% --------------------------------------------------------
\subsubsection{Обчислення густини вздовж осі $z$}
%% --------------------------------------------------------

У наведеному прикладі реалізовано функцію \texttt{plot\_density\_profile}, що обчислює електронну густину вздовж осі $z$ для атома.
Це дозволяє побудувати одноосний «профіль густини» та простежити, як електронна густина спадає при віддаленні від ядра.

\begin{itemize}
  \item Молекулярний об’єкт створюється через \texttt{gto.M}, де вказується атом, базис та спінова мультиплічність.
  \item Виконується розрахунок за методом Гартрі–Фока (RHF або UHF залежно від спіну).
  \item Для кожної точки $z$ обчислюється матриця базисних функцій $\phi_i(\mathbf{r})$, і далі густина:
  \[
  \rho(\mathbf{r}) = \sum_{ij} \phi_i(\mathbf{r}) D_{ij} \phi_j(\mathbf{r}),
  \]
  де $D_{ij}$ --- елементи матриці щільності.
\end{itemize}

Результат зображається графічно: густина $\rho(0,0,z)$ як функція відстані від ядра.
Для нейтральних атомів крива має різкий максимум біля ядра, який швидко спадає експоненційно.

\begin{minted}{python}
from pyscf import gto, scf
from pyscf.tools import cubegen
import numpy as np
import matplotlib.pyplot as plt

def plot_density_profile(symbol, spin, basis='cc-pvdz'):
    """Радіальний розподіл густини"""

    mol = gto.M(
        atom=f'{symbol} 0 0 0',
        basis=basis,
        spin=spin,
        verbose=0
    )

    if spin == 0:
        mf = scf.RHF(mol)
    else:
        mf = scf.UHF(mol)

    mf.verbose = 0
    mf.kernel()

    # Розрахунок густини вздовж осі z
    r_points = np.linspace(0, 5, 200)  # Bohr
    density = []

    dm = mf.make_rdm1()

    for r in r_points:
        coords = np.array([[0, 0, r]])
        rho = mol.eval_gto('GTOval_sph', coords)

        if spin == 0:
            dens = np.einsum('pi,ij,pj->p', rho, dm, rho)[0]
        else:
            dens_a = np.einsum('pi,ij,pj->p', rho, dm[0], rho)[0]
            dens_b = np.einsum('pi,ij,pj->p', rho, dm[1], rho)[0]
            dens = dens_a + dens_b

        density.append(dens)

    # Побудова графіка
    plt.figure(figsize=(10, 6))
    plt.plot(r_points, density, linewidth=2)
    plt.xlabel('Відстань від ядра (Bohr)', fontsize=12)
    plt.ylabel('Електронна густина (e/Bohr³)', fontsize=12)
    plt.title(f'Радіальний розподіл густини {symbol}', fontsize=14)
    plt.grid(True, alpha=0.3)
    plt.tight_layout()
    plt.savefig(f'{symbol}_density.pdf')
    plt.show()

    return r_points, density

# Приклад
r, rho = plot_density_profile('Ne', spin=0)
\end{minted}

\paragraph{Інтерпретація результатів.}
На побудованому графіку $\rho(r)$ спостерігаються чіткі області локалізації електронів:
внутрішні електрони формують центральний пік, тоді як зовнішні оболонки проявляються у вигляді плавних плечей.
Для важчих атомів густина стає більш «зосередженою» біля ядра через сильніше притягання кулонівським потенціалом.

\paragraph{Практична порада.}
При виборі базисного набору (\texttt{cc-pvdz}, \texttt{6-31G**}, тощо) слід мати на увазі, що форма профілю густини істотно залежить від якості базису:
мінімальні базиси дають лише грубу картину, тоді як розширені базиси (\texttt{cc-pVTZ}) відтворюють експоненційний спад більш точно.

%% --------------------------------------------------------
\subsubsection{Сферично усереднена густина}
%% --------------------------------------------------------

Для атомів, що мають сферичну симетрію, зручно розглядати усереднену по всіх напрямах густину:
\[
\rho(r) = \frac{1}{4\pi} \int \rho(\mathbf{r}) \, d\Omega,
\]
де $r = |\mathbf{r}|$ та $d\Omega$ --- елемент тілесного кута.

Ця функція показує, як змінюється густина лише від радіуса $r$, незалежно від напрямку, і є основою для побудови радіальної функції розподілу
\[
P(r) = 4\pi r^2 \rho(r),
\]
що описує, яка частка електронів перебуває у сферичному шарі товщини $dr$ на відстані $r$ від ядра.

\begin{minted}{python}
from pyscf import gto, scf
import numpy as np
import matplotlib.pyplot as plt

def spherical_averaged_density(symbol, spin, basis='cc-pvdz'):
    """Сферично усереднена електронна густина"""

    mol = gto.M(
        atom=f'{symbol} 0 0 0',
        basis=basis,
        spin=spin,
        verbose=0
    )

    if spin == 0:
        mf = scf.RHF(mol)
    else:
        mf = scf.UHF(mol)

    mf.verbose = 0
    mf.kernel()

    dm = mf.make_rdm1()

    # Радіальні точки
    r_points = np.linspace(0.01, 8, 300)

    # Кути для інтегрування (метод Монте-Карло)
    n_angles = 100
    theta = np.random.uniform(0, np.pi, n_angles)
    phi = np.random.uniform(0, 2*np.pi, n_angles)

    density_sph = []

    for r in r_points:
        rho_avg = 0

        for t, p in zip(theta, phi):
            x = r * np.sin(t) * np.cos(p)
            y = r * np.sin(t) * np.sin(p)
            z = r * np.cos(t)

            coords = np.array([[x, y, z]])
            ao_value = mol.eval_gto('GTOval_sph', coords)

            if spin == 0:
                rho_point = np.einsum('pi,ij,pj->p',
                                     ao_value, dm, ao_value)[0]
            else:
                rho_a = np.einsum('pi,ij,pj->p',
                                 ao_value, dm[0], ao_value)[0]
                rho_b = np.einsum('pi,ij,pj->p',
                                 ao_value, dm[1], ao_value)[0]
                rho_point = rho_a + rho_b

            rho_avg += rho_point

        rho_avg /= n_angles
        density_sph.append(rho_avg)

    # Радіальна функція розподілу 4πr²ρ(r)
    radial_dist = 4 * np.pi * r_points**2 * np.array(density_sph)

    # Графіки
    fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(14, 5))

    # Густина ρ(r)
    ax1.plot(r_points, density_sph, linewidth=2)
    ax1.set_xlabel('r (Bohr)', fontsize=12)
    ax1.set_ylabel('ρ(r) (e/Bohr³)', fontsize=12)
    ax1.set_title(f'Електронна густина {symbol}', fontsize=14)
    ax1.grid(True, alpha=0.3)
    ax1.set_yscale('log')

    # Радіальна функція розподілу
    ax2.plot(r_points, radial_dist, linewidth=2, color='red')
    ax2.set_xlabel('r (Bohr)', fontsize=12)
    ax2.set_ylabel('4πr²ρ(r)', fontsize=12)
    ax2.set_title(f'Радіальна функція розподілу {symbol}',
                  fontsize=14)
    ax2.grid(True, alpha=0.3)

    plt.tight_layout()
    plt.savefig(f'{symbol}_spherical_density.pdf')
    plt.show()

    # Перевірка нормування
    dr = r_points[1] - r_points[0]
    total_electrons = np.sum(radial_dist) * dr
    print(f'\nІнтеграл 4πr²ρ(r)dr = {total_electrons:.2f}')
    print(f'Очікується: {mol.nelectron} електронів')

    return r_points, density_sph, radial_dist

# Приклади для різних атомів
r, rho, rdf = spherical_averaged_density('He', spin=0)
r, rho, rdf = spherical_averaged_density('C', spin=2)
r, rho, rdf = spherical_averaged_density('Ne', spin=0)
\end{minted}


\paragraph{Методика обчислення.}
Для кожного радіуса $r$ вибираються випадкові напрями (кутові координати $\theta$, $\phi$) за методом Монте-Карло.
У цих напрямках обчислюється густина $\rho(x,y,z)$, після чого береться середнє значення:
\[
\rho(r) \approx \frac{1}{N} \sum_{k=1}^{N} \rho(r,\theta_k,\phi_k).
\]
Цей підхід забезпечує добру точність навіть при невеликій кількості напрямів $N \sim 100$.

\paragraph{Радіальна функція розподілу.}
На другому графіку зображується $4\pi r^2\rho(r)$ --- це функція, інтеграл від якої по $r$ дає повну кількість електронів:
\[
\int_0^\infty 4\pi r^2\rho(r)\,dr = N_e.
\]
Таким чином, можна перевірити нормування хвильової функції та коректність чисельного інтегрування.

\paragraph{Приклад інтерпретації.}
Для атома гелію максимум $4\pi r^2\rho(r)$ спостерігається приблизно при $r \approx 0.3$~Bohr,
що відповідає найбільш ймовірній відстані електрона від ядра у $1s$-стані.
Для вуглецю або неону виникають додаткові піки, пов’язані з електронами на $2s$ та $2p$ оболонках.

\paragraph{Перевірка нормування.}
Наприкінці виконання функції виводиться значення
\[
\int 4\pi r^2 \rho(r) dr,
\]
яке має збігатися з кількістю електронів у системі, що є корисним тестом правильності побудованої густини.


%% --------------------------------------------------------
\subsection{Порівняння електронних густин різних атомів}
%% --------------------------------------------------------

Ми розглянули, як отримати електронну густину $\rho(\mathbf{r})$ та сферично усереднену густину $\rho(r)$ для окремого атома.  Однак для повного розуміння періодичних закономірностей важливо порівняти, як змінюється форма та протяжність електронної хмари при переході від легких до важчих елементів.

\subsubsection{Фізична мотивація}

Порівняння електронних густин дозволяє:
\begin{itemize}
    \item побачити, як із зростанням атомного номера $Z$ ядро сильніше притягує електрони;
    \item проаналізувати зміну розмірів атома та ефективного радіуса;
    \item виявити закономірності заповнення електронних оболонок;
    \item візуально оцінити зв’язок між структурою густини та положенням елемента в періодичній системі.
\end{itemize}

У програмі нижче реалізовано функцію порівняння радіальних профілів густини для кількох атомів одночасно.
Вона виконує незалежні розрахунки SCF для кожного атома, будує $\rho(r)$ та радіальну функцію $4\pi r^2 \rho(r)$, і виводить результати на одному графіку для порівняння.

\subsubsection{Коментар до реалізації}

Ключові кроки програми:
\begin{enumerate}
    \item Створення об'єкта \texttt{Mole} для кожного атома з базисом \texttt{cc-pvdz} або \texttt{cc-pvtz}.
    \item Проведення SCF-розрахунку типу RHF або UHF залежно від спіну.
    \item Побудова масиву радіальних точок уздовж осі $z$:
    $$ r \in [0, 6] \ \text{Bohr} $$
    \item Обчислення електронної густини як:
    \[
    \rho(r) = \sum_{i,j} \phi_i(r) D_{ij} \phi_j(r),
    \]
    де $\phi_i$ --- атомні орбіталі, $D_{ij}$ --- елементи матриці щільності.
    \item Для кожного атома будується:
    \begin{itemize}
        \item крива $\rho(r)$ --- логарифмічний масштаб показує різке спадання густини;
        \item радіальний розподіл $4\pi r^2\rho(r)$ --- для аналізу оболонкової структури.
    \end{itemize}
\end{enumerate}

\begin{minted}{python}
from pyscf import gto, scf
import numpy as np
import matplotlib.pyplot as plt

def compare_densities(atoms_list, basis='cc-pvdz'):
    """Порівняння електронної густини різних атомів"""

    fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(14, 5))

    colors = plt.cm.tab10(np.linspace(0, 1, len(atoms_list)))

    for (symbol, spin), color in zip(atoms_list, colors):
        mol = gto.M(
            atom=f'{symbol} 0 0 0',
            basis=basis,
            spin=spin,
            verbose=0
        )

        if spin == 0:
            mf = scf.RHF(mol)
        else:
            mf = scf.UHF(mol)

        mf.verbose = 0
        mf.kernel()

        dm = mf.make_rdm1()

        # Густина вздовж осі z
        r_points = np.linspace(0.01, 6, 200)
        density = []

        for r in r_points:
            coords = np.array([[0, 0, r]])
            ao = mol.eval_gto('GTOval_sph', coords)

            if spin == 0:
                rho = np.einsum('pi,ij,pj->p', ao, dm, ao)[0]
            else:
                rho = (np.einsum('pi,ij,pj->p', ao, dm[0], ao)[0] +
                       np.einsum('pi,ij,pj->p', ao, dm[1], ao)[0])

            density.append(rho)

        # Графіки
        ax1.plot(r_points, density, linewidth=2,
                label=f'{symbol} (Z={mol.atom_charge(0)})',
                color=color)

        # Радіальна функція
        radial = 4 * np.pi * r_points**2 * np.array(density)
        ax2.plot(r_points, radial, linewidth=2,
                label=f'{symbol}', color=color)

    ax1.set_xlabel('r (Bohr)', fontsize=12)
    ax1.set_ylabel('ρ(r) (e/Bohr³)', fontsize=12)
    ax1.set_title('Електронна густина', fontsize=14)
    ax1.set_yscale('log')
    ax1.legend()
    ax1.grid(True, alpha=0.3)

    ax2.set_xlabel('r (Bohr)', fontsize=12)
    ax2.set_ylabel('4πr²ρ(r)', fontsize=12)
    ax2.set_title('Радіальний розподіл', fontsize=14)
    ax2.legend()
    ax2.grid(True, alpha=0.3)

    plt.tight_layout()
    plt.savefig('atoms_density_comparison.pdf')
    plt.show()

# Порівняння атомів благородних газів
noble_gases = [
    ('He', 0), ('Ne', 0), ('Ar', 0)
]
compare_densities(noble_gases, basis='cc-pvtz')

# Порівняння атомів 2-го періоду
second_period = [
    ('Li', 1), ('C', 2), ('N', 3), ('O', 2), ('F', 1)
]
compare_densities(second_period, basis='6-31g*')
\end{minted}

\subsubsection{Аналіз результатів}

На графіку для \textbf{благородних газів} (\ce{He}, \ce{Ne}, \ce{Ar}) чітко видно:
\begin{itemize}
    \item з ростом $Z$ максимум густини зміщується ближче до ядра --- електрони сильніше притягуються кулонівським полем;
    \item протяжність хвоста $\rho(r)$ зменшується, атоми стають компактнішими;
    \item радіальні криві $4\pi r^2\rho(r)$ демонструють послідовне збільшення кількості максимумів, що відповідає заповненню нових оболонок.
\end{itemize}

Для \textbf{атомів другого періоду} (\ce{Li} -- \ce{F}) спостерігається:
\begin{itemize}
    \item різке зростання центральної густини у міру збільшення $Z$;
    \item поява другорядного максимуму в $4\pi r^2\rho(r)$, що відповідає електронам $2s$-оболонки;
    \item звуження зовнішньої частини електронної хмари.
\end{itemize}

\subsubsection{Зв’язок із електронними оболонками}

Максимуми радіальної функції розподілу $4\pi r^2\rho(r)$ відповідають областям найбільшої ймовірності перебування електронів певних орбіталей:
\begin{align*}
\text{1s} \rightarrow \text{перший максимум}, \quad
\text{2s, 2p} \rightarrow \text{другий максимум}, \\
\text{3s, 3p, 3d} \rightarrow \text{третій тощо.}
\end{align*}

Таким чином, форма $4\pi r^2\rho(r)$ дає прямий зв’язок між результатами квантово-хімічних розрахунків і традиційною атомною структурою, знайомою студентам з курсу атомної фізики.
Візуальний аналіз таких графіків дозволяє простежити закономірності побудови періодичної системи Менделєєва з точки зору електронної густини.

\subsubsection{Практичні завдання}

\begin{enumerate}
    \item Побудуйте на одному графіку $\rho(r)$ для \ce{Li}, \ce{Na}, \ce{K}. Як змінюється радіус атома?
    \item Знайдіть положення максимумів $4\pi r^2\rho(r)$ для атомів \ce{He}, \ce{Ne}, \ce{Ar}. До яких оболонок вони належать?
    \item Порівняйте радіальні функції для атомів \ce{C} і \ce{O}. Як змінюється густина зовнішньої оболонки?
\end{enumerate}


%% --------------------------------------------------------
\subsubsection{Методичні рекомендації}
%% --------------------------------------------------------

\begin{enumerate}
  \item Для легких атомів (\texttt{H}, \texttt{He}, \texttt{Li}) можна порівняти результати з аналітичними розв’язками рівняння Шредінгера.
  \item Змінюючи базис (наприклад, \texttt{STO-3G}, \texttt{6-31G}, \texttt{cc-pVTZ}), можна дослідити, як збільшується точність відтворення радіального профілю.
  \item Для відкритих оболонок (атомів з неспареними електронами) потрібно враховувати спінову поляризацію --- використовується \texttt{UHF}.
\end{enumerate}

Таким чином, наведені приклади демонструють практичний зв’язок між теоретичними поняттями електронної густини і їх чисельною реалізацією в пакеті \texttt{PySCF}.


%% --------------------------------------------------------
\section{Порівняння методів: RHF vs UHF vs ROHF}
%% --------------------------------------------------------

У квантово-хімічних розрахунках вибір типу наближення Гартрі–Фока залежить від спінового стану системи.
Методи \textbf{RHF}, \textbf{UHF} та \textbf{ROHF} відрізняються тим, як вони поводяться із спіновими функціями електронів --- тобто, чи допускають різні орбіталі для $\alpha$- і $\beta$-електронів.

\begin{itemize}
    \item \textbf{RHF (Restricted Hartree–Fock)} --- усі електрони спарені, кожна просторова орбіталь заповнена двома електронами з протилежними спінами.
    Підходить лише для синглетних закритих оболонок.

    \item \textbf{UHF (Unrestricted Hartree–Fock)} --- орбіталі для $\alpha$- і $\beta$-електронів дозволено різні.
    Цей метод придатний для відкритих оболонок (наприклад, атомів з неспареними електронами), однак може страждати від \emph{спінового забруднення}.

    \item \textbf{ROHF (Restricted Open-Shell Hartree–Fock)} --- компроміс: спільні орбіталі для парних електронів і різні --- лише для неспарених.
    Це забезпечує правильний спіновий симетрійний стан без забруднення.
\end{itemize}

%% --------------------------------------------------------
\subsection{Тестовий випадок: атом Вуглецю}
%% --------------------------------------------------------

Вуглець має конфігурацію $1s^2 2s^2 2p^2$ і основний стан $^3P$ (триплет).
Отже, система має два неспарені електрони ($S=1$), а отже $\langle S^2 \rangle = S(S+1) = 2.0$.

Далі наведено приклад прямого порівняння результатів методів UHF і ROHF для атома C у триплетному стані з використанням базису \texttt{cc-pVTZ}.

\begin{minted}{python}
from pyscf import gto, scf

# Атом C: [He] 2s² 2p², основний стан ³P
basis = 'cc-pvtz'

print('Порівняння методів для атома Вуглецю (³P)')
print('='*70)

# Молекула
mol = gto.M(
    atom='C 0 0 0',
    basis=basis,
    spin=2,  # Триплет
    symmetry=True,
    verbose=0
)

# UHF
print('\n1. Unrestricted Hartree-Fock (UHF)')
print('-'*70)
mf_uhf = scf.UHF(mol)
mf_uhf.verbose = 4
e_uhf = mf_uhf.kernel()

s2_uhf = mf_uhf.spin_square()
print(f'\nЕнергія (UHF): {e_uhf:.8f} Ha')
print(f'<S²> (UHF): {s2_uhf[0]:.6f} (очікується 2.0)')
print(f'Забруднення спіном: {s2_uhf[0] - 2.0:.6f}')

# ROHF
print('\n2. Restricted Open-shell Hartree-Fock (ROHF)')
print('-'*70)
mf_rohf = scf.ROHF(mol)
mf_rohf.verbose = 4
e_rohf = mf_rohf.kernel()

s2_rohf = mf_rohf.spin_square()
print(f'\nЕнергія (ROHF): {e_rohf:.8f} Ha')
print(f'<S²> (ROHF): {s2_rohf[0]:.6f} (очікується 2.0)')

# Порівняння
print('\n' + '='*70)
print('ПОРІВНЯННЯ')
print('='*70)
print(f'ΔE (UHF-ROHF): {(e_uhf - e_rohf)*1000:.4f} mHa')
print(f'ΔE (UHF-ROHF): {(e_uhf - e_rohf)*627.509:.4f} kcal/mol')

print(f'\nЗабруднення спіном:')
print(f'  UHF:  {s2_uhf[0] - 2.0:.6f}')
print(f'  ROHF: {s2_rohf[0] - 2.0:.6f}')

# Орбітальні енергії
print(f'\nОрбітальні енергії (Ha):')
print(f'{"Орбіталь":15s} {"UHF (α)":12s} {"UHF (β)":12s} {"ROHF":12s}')
print('-'*70)

n_show = 5
for i in range(n_show):
    label = mol.ao_labels()[i] if i < len(mol.ao_labels()) else f'MO{i+1}'
    e_uhf_a = mf_uhf.mo_energy[0][i]
    e_uhf_b = mf_uhf.mo_energy[1][i]
    e_rohf_i = mf_rohf.mo_energy[i]

    print(f'{label:15s} {e_uhf_a:12.6f} {e_uhf_b:12.6f} {e_rohf_i:12.6f}')
\end{minted}

%% --------------------------------------------------------
\subsection{Теоретичний аналіз результатів}
%% --------------------------------------------------------

\subsubsection{Спінове забруднення}

Для триплетного стану очікується:
\[
\langle S^2 \rangle = S(S+1) = 1(1+1) = 2.0.
\]
Якщо результат UHF дає $\langle S^2 \rangle > 2.0$, це свідчить про \textit{спінове забруднення} --- хвильова функція містить домішку інших спінових станів (наприклад, $^5S$).
Це відбувається через те, що UHF не примушує $\alpha$- і $\beta$-орбіталі бути ортогональними, тому спінова симетрія порушується.

\textbf{ROHF}, на відміну від цього, зберігає точне спінове квантове число, тому $\langle S^2 \rangle$ збігається з теоретичним значенням.

\subsubsection{Енергетичне порівняння}

UHF зазвичай дає трохи нижчу енергію, ніж ROHF, оскільки має більше варіаційної свободи.
Різниця $\Delta E = E_{\mathrm{UHF}} - E_{\mathrm{ROHF}}$ зазвичай незначна (менше кількох мілігаусів), однак у системах з сильним спіновим змішуванням може бути суттєвою.

\subsubsection{Орбітальні енергії}

UHF формує два набори орбіталей --- для $\alpha$- і $\beta$-електронів.
Тому орбітальні енергії можуть відрізнятись:
\[
\varepsilon_i^{(\alpha)} \neq \varepsilon_i^{(\beta)}.
\]
У ROHF усі парні орбіталі спільні, тож орбітальні енергії чітко впорядковані відповідно до симетрії та спіну.


%% --------------------------------------------------------
\subsection{Систематичне порівняння для всіх атомів}
%% --------------------------------------------------------

Щоб узагальнити різницю між методами UHF та ROHF, виконаємо серію розрахунків для
кількох відкритооболонкових атомів перших двох періодів. Це дозволить оцінити
енергетичну різницю $\Delta E = E_{\text{UHF}} - E_{\text{ROHF}}$ і побачити,
чи зберігає ROHF спінову симетрію без втрати точності.



\begin{minted}{python}
from pyscf import gto, scf
import numpy as np

atoms_open_shell = [
    ('H',  1), ('Li', 1), ('B', 1), ('C', 2),
    ('N',  3), ('O',  2), ('F', 1)
]

basis = '6-31g*'

print(f'Порівняння UHF vs ROHF (базис: {basis})')
print('='*80)
print(f'{"Атом":4s} {"Спін":4s} {"E(UHF), Ha":15s} {"E(ROHF), Ha":15s} '
      f'{"ΔE, mHa":10s}')
print('-'*80)

for symbol, spin in atoms_open_shell:
    mol = gto.M(
        atom=f'{symbol} 0 0 0',
        basis=basis,
        spin=spin,
        verbose=0
    )

    # UHF
    mf_uhf = scf.UHF(mol)
    mf_uhf.verbose = 0
    mf_uhf.conv_tol = 1e-10
    e_uhf = mf_uhf.kernel()

    # ROHF
    mf_rohf = scf.ROHF(mol)
    mf_rohf.verbose = 0
    mf_rohf.conv_tol = 1e-10
    e_rohf = mf_rohf.kernel()

    delta = (e_uhf - e_rohf) * 1000  # mHa

    print(f'{symbol:4s} {spin:4d} {e_uhf:15.8f} {e_rohf:15.8f} {delta:10.4f}')

print('='*80)
print('\nПримітка: UHF зазвичай дає нижчу енергію, але з')
print('          забрудненням спіну. ROHF зберігає чисту')
print('          спінову симетрію.')
\end{minted}


\noindent
\textbf{Інтерпретація результатів.}
Як правило, для легких атомів (H, Li, B) енергії UHF і ROHF майже збігаються.
Для атомів із більшою кількістю незапарених електронів (C, N, O, F)
різниця у кілька міллігаусів відображає більшу гнучкість UHF,
що дозволяє частково знизити енергію ціною забруднення спіном
($\langle S^2 \rangle > S(S+1)$).

Таким чином, ROHF --- це більш строгий метод із правильною спіновою симетрією,
а UHF --- енергетично вигідніший, але менш «фізично чистий». У практичних
обчисленнях ROHF часто слугує базовою точкою для подальших кореляційних
методів (MP2, CCSD, CASSCF).

\subsubsection{Практичне значення}

Порівняння методів RHF, UHF і ROHF дозволяє студентам зрозуміти:
\begin{itemize}
    \item коли можна використовувати RHF (синглети закритих оболонок);
    \item коли необхідно застосовувати UHF (відкриті оболонки, магнітні системи);
    \item у яких випадках варто віддати перевагу ROHF (спінова чистота, мінімізація забруднення).
\end{itemize}

\subsubsection{Контрольне завдання}

\begin{enumerate}
    \item Повторіть розрахунок для атомів \ce{O} (спін = 2) і \ce{N} (спін = 3).
    Порівняйте $\langle S^2 \rangle$ для UHF і ROHF.
    \item Для кожного атома побудуйте різницю енергій UHF–ROHF у мілігаусах.
    \item Проаналізуйте, як спінове забруднення зростає зі збільшенням кількості неспарених електронів.
\end{enumerate}



%% --------------------------------------------------------
\section{Складні випадки та збіжність}
%% --------------------------------------------------------

Розрахунки у квантовій хімії не завжди проходять гладко. Навіть для, здавалося б, простих атомів або малих молекул можуть виникати проблеми збіжності --- коли ітераційний процес самозгодженого поля (SCF) не може досягти стабільного рішення.
Особливо це стосується перехідних металів, систем із сильною кореляцією електронів або випадків із виродженими орбіталями.
У цьому розділі наведено практичні прийоми, які допомагають стабілізувати розрахунок, а також приклади програмного коду на базі бібліотеки \texttt{PySCF}.


Основні джерела труднощів:
\begin{itemize}
  \item сильна електронна кореляція в незаповнених $d$- та $f$-оболонках;
  \item мала різниця енергій між орбіталями (виродження);
  \item вибір невдалого початкового наближення хвильової функції;
  \item надто жорсткі або надто м’які критерії збіжності.
\end{itemize}

У наступних підрозділах ми розглянемо конкретні стратегії для подолання таких труднощів.

%% --------------------------------------------------------
\subsection{Перехідні метали}
%% --------------------------------------------------------


Перехідні метали є одними з найпроблемніших систем для збіжності SCF.
Причини --- сильна кореляція електронів \(d\)-оболонки,
множинність близьких за енергією станів спіну та
значна роль релятивістичних ефектів.
Навіть у межах методу Гартрі–Фока
функціонал енергії має кілька локальних мінімумів,
і звичайна ітераційна процедура може «застрягнути» в некоректному стані.

У PySCF це часто проявляється у вигляді:
\begin{itemize}
  \item осциляцій енергії між ітераціями,
  \item дивергентного DIIS,
  \item різкої зміни спінового моменту між кроками.
\end{itemize}

Типовий приклад — атоми Fe, Co, Ni або їхні оксиди,
де різниця між конфігураціями високого й низького спіну
становить лише декілька сотих гартрі.

\begin{minted}{python}
from pyscf import gto, scf

mol = gto.M(atom='Co 0 0 0', basis='def2-svp', spin=3)
mf = scf.UHF(mol).run()
print('Converged?', mf.converged)
\end{minted}

Перехідні метали є класичним прикладом систем, де звичайні методи SCF часто не конвергують або дають фізично некоректний результат.
Це зумовлено тим, що у таких атомів одночасно заповнюються $3d$- та $4s$-орбіталі, енергії яких близькі. У результаті електрон може ``перестрибувати'' між орбіталями під час ітерацій, порушуючи стабільність процесу.

У прикладі нижче подано універсальну функцію для обчислення енергії атомів перехідних металів із урахуванням практичних порад:

\begin{itemize}
  \item використовується метод UHF (неспарені електрони важливі для коректного опису спіну);
  \item уведено \texttt{level shift}, що зміщує енергетичний спектр і полегшує збіжність;
  \item застосовано розширений DIIS-простір (метод прискорення збіжності);
  \item при необхідності переходять до Ньютона–Рафсона для уточнення рішення;
  \item результати контролюються через значення $\langle S^2 \rangle$.
\end{itemize}

Після кожного розрахунку порівнюється очікуване значення спіну зі знайденим, а також обчислюється ``забруднення спіном'' --- показник, наскільки рішення відхиляється від ідеального стану.

\begin{minted}{python}
from pyscf import gto, scf

def transition_metal_calculation(symbol, spin, basis='def2-svp'):
    """
    Розрахунок атома перехідного металу
    Часто потребує спеціальних налаштувань
    """

    print(f'\nРозрахунок {symbol} (2S={spin})')
    print('='*60)

    mol = gto.M(
        atom=f'{symbol} 0 0 0',
        basis=basis,
        spin=spin,
        symmetry=False,  # Іноді краще без симетрії
        verbose=0
    )

    mf = scf.UHF(mol)

    # Налаштування для важких випадків
    mf.conv_tol = 1e-8
    mf.max_cycle = 200
    mf.level_shift = 0.5  # Level shift допомагає конвергенції
    mf.diis_space = 12
    mf.init_guess = 'atom'

    print('Спроба 1: UHF з level shift...')
    mf.verbose = 4
    energy = mf.kernel()

    if not mf.converged:
        print('\nНе конвергувало! Спроба 2: Newton-Raphson...')
        mf = mf.newton()
        mf.max_cycle = 50
        energy = mf.kernel()

    if mf.converged:
        s2 = mf.spin_square()
        expected_s2 = spin * (spin + 2) / 4

        print(f'\nРезультати:')
        print(f'  Енергія: {energy:.8f} Ha')
        print(f'  <S²>: {s2[0]:.4f} (очікується {expected_s2:.4f})')
        print(f'  Забруднення: {s2[0] - expected_s2:.4f}')
    else:
        print('\nНЕ ВДАЛОСЯ ДОСЯГТИ КОНВЕРГЕНЦІЇ!')

    return mf, energy if mf.converged else None

# Приклади перехідних металів
# Sc: [Ar] 3d¹ 4s², ²D
mf_sc, e_sc = transition_metal_calculation('Sc', spin=1)

# Ti: [Ar] 3d² 4s², ³F
mf_ti, e_ti = transition_metal_calculation('Ti', spin=2)

# Cr: [Ar] 3d⁵ 4s¹, ⁷S
mf_cr, e_cr = transition_metal_calculation('Cr', spin=6)

# Mn: [Ar] 3d⁵ 4s², ⁶S
mf_mn, e_mn = transition_metal_calculation('Mn', spin=5)

# Fe: [Ar] 3d⁶ 4s², ⁵D
mf_fe, e_fe = transition_metal_calculation('Fe', spin=4)
\end{minted}

Такий підхід забезпечує стабільність навіть для важких атомів --- наприклад, Cr, Mn або Fe, де стандартний SCF часто не сходиться.

%% --------------------------------------------------------
\subsection{Використання дробових заповнень}
%% --------------------------------------------------------

Ще одна причина проблем зі збіжністю --- наявність вироджених або майже вироджених орбіталей. У таких випадках система ``вагається'', яку саме конфігурацію обрати, і стандартний SCF може осцилювати без досягнення стабільного мінімуму.

Один із ефективних підходів --- застосування \textit{дробових заповнень орбіталей} (англ. \textit{fractional occupations}).
Ідея полягає у тому, що замість жорсткого заповнення $0$ або $1$ для кожної орбіталі вводиться часткове заповнення, яке імітує теплове розмазування Фермі–Дірака:
\[
f_i = \frac{1}{1 + e^{(\varepsilon_i - \mu)/kT}},
\]
де $f_i$ --- ефективне заповнення $i$-ї орбіталі, $\varepsilon_i$ --- її енергія, $\mu$ --- хімічний потенціал, а $kT$ --- параметр ``розмазування''.

Цей підхід згладжує різкі переходи між виродженими орбіталями і дозволяє SCF знайти стабільне рішення.

Нижче наведено приклад для атома ванадію, у якого типово спостерігаються проблеми збіжності через близькість енергетичних рівнів $3d$ і $4s$.


\begin{minted}{python}
from pyscf import gto, scf

# Важкий випадок: атом з близькими за енергією орбіталями
mol = gto.M(
    atom='V 0 0 0',
    basis='cc-pvdz',
    spin=3,
    verbose=0
)

print('Розрахунок V з дробовими заповненнями')
print('='*60)

# Стандартний UHF може не конвергувати
mf = scf.UHF(mol)
mf.verbose = 0
mf.max_cycle = 100

try:
    energy = mf.kernel()
    if not mf.converged:
        raise RuntimeError('Не конвергувало')
except:
    print('Стандартний UHF не конвергував')

# Використання дробових заповнень (smearing)
print('\nСпроба з дробовими заповненнями...')

mf = scf.UHF(mol)
mf = scf.addons.frac_occ(mf)
mf.verbose = 4
energy = mf.kernel()

if mf.converged:
    print(f'\nУспішно! Енергія: {energy:.8f} Ha')
else:
    print('\nВсе одно не конвергувало')
\end{minted}

Як видно, якщо звичайний UHF не конвергує, можна скористатися \texttt{scf.addons.frac\_occ(mf)}, що вмикає дробові заповнення.
Методика добре працює для окремих атомів, радикалів і навіть для малих кластерів перехідних металів.

%% --------------------------------------------------------
\subsection{Стратегії досягнення конвергенції}
%% --------------------------------------------------------

Проблема збіжності --- одна з найчастіших у практиці квантово-хімічних розрахунків.
Ітераційна процедура самозгодженого поля (SCF) повинна забезпечити стабільне розв’язання рівнянь Гартрі–Фока, однак у реальних системах --- особливо для відкритих оболонок, перехідних металів або вироджених станів --- енергія може коливатися, DIIS може втрачати стабільність, а розрахунок сходиться до нефізичного мінімуму.

Для таких випадків доцільно застосовувати \textit{послідовну стратегію стабілізації SCF}, у якій різні методи збільшення стійкості перевіряються крок за кроком --- від простих до складніших.

\medskip

\noindent\textbf{Основні прийоми стабілізації:}
\begin{enumerate}
  \item стандартний UHF;
  \item зсув рівнів (\texttt{level\_shift}), що зменшує вплив віртуальних орбіталей;
  \item збільшення DIIS-простору (\texttt{diis\_space});
  \item атомне початкове наближення (\texttt{init\_guess='atom'});
  \item уточнення за методом Ньютона–Рафсона;
  \item дробові заповнення (\texttt{frac\_occ}) при вироджених станах.
\end{enumerate}

\noindent Нижче подано узагальнений алгоритм, який автоматично перебирає ці стратегії для пошуку збіжного рішення.

\begin{minted}{python}
from pyscf import gto, scf

def convergence_strategies(symbol, spin, basis='def2-svp'):
    """
    Покрокова стабілізація SCF для складних систем
    """
    mol = gto.M(atom=f'{symbol} 0 0 0', basis=basis, spin=spin, verbose=0)

    strategies = [
        ('Стандартний UHF', {}),
        ('UHF з level shift', {'level_shift': 0.3}),
        ('UHF з більшим DIIS', {'diis_space': 15}),
        ('UHF з атомним guess', {'init_guess': 'atom'}),
        ('Метод Ньютона–Рафсона', {'newton': True}),
        ('Дробові заповнення', {'frac_occ': True}),
    ]

    print(f'=== Тестування стратегій конвергенції для {symbol} ===')

    for name, params in strategies:
        print(f'\n→ {name}')
        mf = scf.UHF(mol)
        mf.max_cycle = 100
        mf.conv_tol = 1e-9

        for k, v in params.items():
            if k in ('newton', 'frac_occ'):
                continue
            setattr(mf, k, v)

        try:
            if params.get('newton'):
                mf = mf.newton()
            if params.get('frac_occ'):
                mf = scf.addons.frac_occ(mf)
            energy = mf.kernel()
            if mf.converged:
                print(f'✓ Успіх: E = {energy:.8f} Ha')
                return mf, energy
            else:
                print('✗ Не конвергувало')
        except Exception as e:
            print(f'✗ Помилка: {e}')
    print('\n⚠ Жодна стратегія не спрацювала.')
    return None, None

# Приклад: перехідний метал
mf, e = convergence_strategies('Co', spin=3)
\end{minted}

\paragraph{Фізичний сенс прийомів.}
\begin{itemize}
  \item \textbf{Level shift.} Тимчасово підвищує енергії віртуальних орбіталей, запобігаючи коливанням поля.
  \item \textbf{DIIS-простір.} Збільшення пам’яті історії ітерацій покращує апроксимацію самозгодженого стану.
  \item \textbf{Atom guess.} Використовує атомні орбіталі як старт, що ближче до фізичного рішення.
  \item \textbf{Newton–Raphson.} Прискорює збіжність у зоні поблизу мінімуму функціоналу енергії.
  \item \textbf{Fractional occupations.} Згладжують виродження, дозволяючи системі знайти стабільний середній стан.
\end{itemize}

\paragraph{Практичні рекомендації.}
\begin{itemize}
  \item Для великих систем зменшіть точність (\texttt{conv\_tol=1e-6}) для попереднього тесту.
  \item Якщо спостерігаються осциляції енергії --- додайте \texttt{level\_shift=0.5}.
  \item Якщо \texttt{UHF} не сходиться --- спробуйте \texttt{init\_guess='atom'} або \texttt{symmetry=False}.
  \item Завжди перевіряйте фізичність розв’язку через $\langle S^2 \rangle$.
\end{itemize}

Таким чином, навіть якщо стандартний SCF не збігається,
послідовне застосування описаних методів практично гарантує знаходження стабільного фізично коректного рішення.



%% --------------------------------------------------------
\section{Практичні завдання}
%% --------------------------------------------------------

%% --------------------------------------------------------
\subsection{Завдання 1: Систематичне дослідження}
%% --------------------------------------------------------

\begin{minted}{python}
"""
ЗАВДАННЯ 1: Розрахуйте енергії всіх атомів першого періоду
(H, He) з різними базисними наборами. Побудуйте графік
збіжності енергії до базисної межі.

Базиси: sto-3g, 6-31g, cc-pvdz, cc-pvtz, cc-pvqz, cc-pv5z
"""

from pyscf import gto, scf
import matplotlib.pyplot as plt

# Ваш код тут
\end{minted}

%% --------------------------------------------------------
\subsection{Завдання 2: Енергії іонізації}
%% --------------------------------------------------------

\begin{minted}{python}
"""
ЗАВДАННЯ 2: Обчисліть першу та другу енергії іонізації
для атомів Li, Be, B, C, N, O, F, Ne. Порівняйте з
експериментальними значеннями.

IE₁ = E(A⁺) - E(A)
IE₂ = E(A²⁺) - E(A⁺)

Використайте базис cc-pvtz
"""

# Ваш код тут
\end{minted}


%% --------------------------------------------------------
\subsection{Завдання 3: Спектроскопічні константи}
%% --------------------------------------------------------

\begin{minted}{python}
"""
ЗАВДАННЯ 3: Для атома Карбону розрахуйте енергетичну
різницю між основним триплетним станом (³P) та
збудженими станами (¹D та ¹S).

Підказка: використайте різні спінові конфігурації
"""

# Ваш код тут
\end{minted}

%% --------------------------------------------------------
\subsection{Завдання 4: Залежність від базису}
%% --------------------------------------------------------

\begin{minted}{python}
"""
ЗАВДАННЯ 4: Дослідіть, як додавання дифузних функцій
впливає на енергію та дипольну поляризованість атома
Кисню (O).

Порівняйте: cc-pvdz vs aug-cc-pvdz, cc-pvtz vs aug-cc-pvtz
"""

# Ваш код тут
\end{minted}

%% --------------------------------------------------------
\section{Резюме}
%% --------------------------------------------------------

У цьому розділі ми детально вивчили метод Хартрі-Фока для атомних систем:

\begin{itemize}
    \item \textbf{Теоретичні основи} --- рівняння HF, детермінант Слейтера, оператор Фока
    \item \textbf{Варіанти методу} --- RHF для замкнених оболонок, UHF для відкритих, ROHF як компроміс
    \item \textbf{Одноелектронні системи} --- H атом як тестовий випадок
    \item \textbf{Багатоелектронні атоми} --- He та атоми другого періоду
    \item \textbf{Аналіз результатів} --- орбітальні енергії, заселеності, спінова густина
    \item \textbf{Складні випадки} --- перехідні метали, стратегії конвергенції
\end{itemize}

\subsection{Ключові висновки}

\begin{enumerate}
    \item Метод HF дає добре якісне описання атомних систем, але не враховує кореляцію електронів
    \item Вибір між RHF/UHF/ROHF залежить від спінової структури системи
    \item UHF страждає від забруднення спіном, але зазвичай дає нижчу енергію
    \item Для важких атомів (перехідні метали) потрібні спеціальні техніки конвергенції
    \item Якість результатів сильно залежить від вибору базисного набору
\end{enumerate}

У наступному розділі ми розглянемо теорію функціоналу густини (DFT), яка часто дає кращі результати для багатоелектронних систем.